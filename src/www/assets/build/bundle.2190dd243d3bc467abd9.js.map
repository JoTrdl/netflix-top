{"version":3,"sources":["webpack:///bundle.2190dd243d3bc467abd9.js","webpack:///webpack/bootstrap 2190dd243d3bc467abd9","webpack:///./index.js","webpack:////Users/jtroendle/Documents/netflix-top/~/riot/riot.js","webpack:////Users/jtroendle/Documents/netflix-top/~/lodash/isPlainObject.js","webpack:////Users/jtroendle/Documents/netflix-top/~/redux/lib/compose.js","webpack:////Users/jtroendle/Documents/netflix-top/~/redux/lib/createStore.js","webpack:////Users/jtroendle/Documents/netflix-top/~/redux/lib/utils/warning.js","webpack:///./tags/app.tag","webpack:///./tags/footer.tag","webpack:///./tags/header/category.tag","webpack:///./tags/header/header.tag","webpack:///./tags/item.tag","webpack:///../store/index.js","webpack:////Users/jtroendle/Documents/netflix-top/~/colorchart/lib/canvas.js","webpack:////Users/jtroendle/Documents/netflix-top/~/colorchart/lib/index.js","webpack:////Users/jtroendle/Documents/netflix-top/~/colorchart/~/quantize/quantize.js","webpack:////Users/jtroendle/Documents/netflix-top/~/isomorphic-fetch/fetch-npm-browserify.js","webpack:////Users/jtroendle/Documents/netflix-top/~/isomorphic-fetch/~/whatwg-fetch/fetch.js","webpack:////Users/jtroendle/Documents/netflix-top/~/lodash/_getPrototype.js","webpack:////Users/jtroendle/Documents/netflix-top/~/lodash/_isHostObject.js","webpack:////Users/jtroendle/Documents/netflix-top/~/lodash/isObjectLike.js","webpack:////Users/jtroendle/Documents/netflix-top/~/offline-plugin/runtime.js","webpack:////Users/jtroendle/Documents/netflix-top/~/redux/lib/applyMiddleware.js","webpack:////Users/jtroendle/Documents/netflix-top/~/redux/lib/bindActionCreators.js","webpack:////Users/jtroendle/Documents/netflix-top/~/redux/lib/combineReducers.js","webpack:////Users/jtroendle/Documents/netflix-top/~/redux/lib/index.js","webpack:////Users/jtroendle/Documents/netflix-top/~/redux/~/symbol-observable/index.js","webpack:////Users/jtroendle/Documents/netflix-top/~/redux/~/symbol-observable/ponyfill.js","webpack:///(webpack)/buildin/amd-options.js","webpack:///./tags \\.tag$"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","i","Object","prototype","hasOwnProperty","_m","args","slice","fn","a","b","apply","this","concat","riot","window","SERVICE_URL","install","req","keys","forEach","key","store","colorchart","document","addEventListener","mount","__WEBPACK_AMD_DEFINE_RESULT__","undefined","mkitem","expr","val","item","pos","unmountRedundant","items","tags","t","length","j","splice","unmount","moveNestedTags","child","tagName","tag","isArray","each","moveChildTag","addVirtual","src","target","sib","el","_root","_virts","nextSibling","insertBefore","appendChild","push","moveVirtual","len","_each","dom","parent","remAttr","hasKeys","mustReorder","getAttr","T_STRING","getTagName","impl","__tagImpl","tmpl","getOuterHTML","useRoot","SPECIAL_TAGS_REGEX","test","root","parentNode","ref","createTextNode","getTag","isOption","toLowerCase","oldItems","isVirtual","loopKeys","one","removeChild","stub","on","frag","createDocumentFragment","map","itemsLength","_mustReorder","T_OBJECT","oldPos","indexOf","Tag","isLoop","hasImpl","cloneNode","innerHTML","firstChild","update","childNodes","_item","defineProperty","FIREFOX","multiple","n","__riot1374","selectedIndex","parseNamedElements","childTags","forceParsingNamed","walk","nodeType","initChildTag","setNamed","parseExpressions","expressions","addExpr","extra","hasExpr","extend","attr","type","nodeValue","attributes","name","bool","split","value","conf","updateOpts","ctx","self","opts","toCamel","normalizeData","data","T_UNDEF","isWritable","inheritFromParent","k","mustSync","RESERVED_WORDS_BLACKLIST","contains","propsInSyncWithParent","onChildUpdate","toggle","isMount","evt","observable","inherit","cleanUpData","_tag","isMounted","__uid","mkdom","isInherited","isObject","trigger","rAF","arguments","mix","instance","mixin","isFunction","getOwnPropertyNames","bind","init","globalMixin","GLOBAL_MIXIN","attrs","walkAttributes","v","setAttr","isInStub","keepRootTag","ptag","tagIndex","__virtualDom","getImmediateCustomParentTag","_riot_id","RIOT_TAG_IS","RIOT_TAG","off","setEventHandler","handler","e","_parent","event","currentTarget","srcElement","which","charCode","keyCode","preventDefault","returnValue","preventUpdate","insertTo","node","before","attrName","IE_VERSION","add","remove","inStub","style","display","startsWith","RIOT_PREFIX","els","T_FUNCTION","outerHTML","container","mkEl","setInnerHTML","html","doc","DOMParser","parseFromString","ownerDocument","importNode","documentElement","isSVGTag","SVG_TAGS_LIST","removeAttribute","string","replace","_","toUpperCase","getAttribute","setAttribute","addChildTag","cachedTag","newPos","options","enumerable","writable","configurable","namedTag","obj","arr","Array","props","getOwnPropertyDescriptor","o","re","exec","isSvg","createElementNS","createElement","$$","selector","querySelectorAll","$","querySelector","Child","getNamedKey","isArr","str","mountTo","_innerHTML","version","settings","documentMode","InstallTrigger","onEachEvent","indx","es","l","substring","callbacks","defineProperties","events","ns","typed","cb","fns","arglen","busy","DEFAULT_PARSER","path","DEFAULT_SECOND_PARSER","filter","RegExp","REPLACE","match","debounce","delay","clearTimeout","setTimeout","start","autoExec","debouncedEmit","emit","win","ADD_EVENT_LISTENER","POPSTATE","HASHCHANGE","clickEvent","click","Router","central","s","normalize","isString","getPathFromRoot","href","loc","RE_ORIGIN","getPathFromBase","base","force","isRoot","emitStackLevel","MAX_EMIT_STACK_LEVEL","emitStack","current","TRIGGER","shift","metaKey","ctrlKey","shiftKey","defaultPrevented","nodeName","HAS_ATTRIBUTE","go","title","shouldReplace","hist","replaceState","pushState","routeFound","parser","secondParser","EVENT_LISTENER","REMOVE_EVENT_LISTENER","history","location","prot","ontouchstart","started","first","second","third","r","some","action","mainRouter","route","create","newSubRouter","router","stop","arg","fn2","query","q","readyState","brackets","UNDEF","_loopback","_rewrite","bp","_cache","source","global","REGLOB","_create","pair","DEFAULT","_pairs","Error","S_QBLOCKS","_brackets","reOrIdx","_regex","_reset","cachedBrackets","_setSettings","set","get","_settings","R_MLCOMMS","R_STRINGS","FINDBRACES","(","[","{","_bp","unescapeStr","isexpr","parts","skipBraces","ch","ix","recch","lastIndex","index","trim","array","_tmpl","_logErr","err","errorHandler","riotData","_getTmpl","Function","qstr","RE_DQUOTE","list","_parseExpr","join","RE_QBMARK","asText","mm","lv","ir","RE_BREND","RE_QBLOCK","div","CH_IDEXPR","cnt","RE_CSNAME","jsb","rightContext","_wrapExpr","tb","JS_VARNAME","mvar","JS_CONTEXT","JS_NOPROPS","haveRaw","hasRaw","parse","_mkdom","templ","replaceYield","tblTags","specialTags","select","tname","rootEls","childElementCount","reHasYield","reYieldSrc","text","reYieldDest","def","reYieldAll","tr","th","td","col","styleManager","_riot","inject","styleNode","newNode","userNode","replaceChild","getElementsByTagName","cssTextProp","styleSheet","stylesToInject","css","cssText","w","raf","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","navigator","userAgent","lastTime","nowtime","Date","now","timeout","Math","max","util","mixins","globals","_id","g","tag2","addRiotTags","selectAllTags","pushTags","riotTag","allTags","nodeList","_el","vdom","isPlainObject","isObjectLike","objectToString","objectTag","isHostObject","proto","getPrototype","Ctor","constructor","funcToString","objectCtorString","objectProto","toString","compose","_len","funcs","_key","_ret","last","rest","reduceRight","composed","f","__esModule","_interopRequireDefault","default","createStore","reducer","initialState","enhancer","ensureCanMutateNextListeners","nextListeners","currentListeners","getState","currentState","subscribe","listener","isSubscribed","dispatch","_isPlainObject2","isDispatching","currentReducer","listeners","replaceReducer","nextReducer","ActionTypes","INIT","_ref","outerSubscribe","observer","observeState","next","TypeError","unsubscribe","_symbolObservable2","_ref2","_isPlainObject","_symbolObservable","warning","message","console","error","_this","state","fetchCategory","category","fetch","then","response","json","close","open","opened","selected","colorsmap","desc","body","backgroundColor","color","100","new","anime","children","classic","comedy","documentary","drama","faith","foreign","gay","horror","independent","music","romance","fantasy","special","sports","shows","thriller","change","isServer","stopImmediatePropagation","lazyload","rect","getBoundingClientRect","inView","top","left","bottom","innerHeight","clientHeight","right","innerWidth","clientWidth","img","removeEventListener","_this2","redux","INITIAL_STATE","STORE","rendered","isFetching","hasError","actions","UPDATE_TITLE","assign","SERVER_RENDERED","UPDATE_CATEGORY","FETCH_INIT","FETCH_SUCCESS","FETCH_ERROR","Canvas","canvas","context","getContext","width","height","drawImage","getSize","getData","getImageData","Colormap","quantize","count","quality","mapQuality","colorCount","offset","canvasData","pixels","size","rgbArray","result","palette","getDominant","pv","d","naturalOrder","sum","reduce","MMCQ","getColorIndex","sigbits","PQueue","comparator","sort","contents","sorted","peek","pop","debug","VBox","r1","r2","g1","g2","b1","b2","histo","vbox","CMap","vboxes","volume","getHisto","rval","gval","bval","histosize","pixel","rshift","vboxFromPixels","rmin","rmax","gmin","gmax","bmin","bmax","medianCutApply","doCut","vbox1","vbox2","d2","dim1","dim2","count2","partialsum","total","copy","min","lookaheadsum","rw","gw","bw","maxw","maxcolors","iter","lh","ncolors","niters","maxIterations","nColors","pq","fractByPopulations","pq2","cmap","_volume","_count_set","npix","_count","avg","_avg","hval","histoindex","ntot","mult","rsum","gsum","bsum","vb","nearest","d1","pColor","sqrt","pow","forcebw","lowest","idx","highest","normalizeName","String","normalizeValue","iteratorFor","iterator","done","support","iterable","Symbol","Headers","headers","append","consumed","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","Body","_initBody","_bodyInit","_bodyText","Blob","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","searchParams","URLSearchParams","arrayBuffer","ArrayBuffer","rejected","decode","JSON","normalizeMethod","method","upcased","methods","Request","input","url","credentials","mode","referrer","form","bytes","decodeURIComponent","xhr","head","pairs","getAllResponseHeaders","header","Response","bodyInit","status","ok","statusText","values","getAll","has","callback","thisArg","entries","clone","redirectStatuses","redirect","RangeError","responseURL","getResponseHeader","request","XMLHttpRequest","responseText","ontimeout","withCredentials","responseType","setRequestHeader","send","polyfill","nativeGetPrototype","getPrototypeOf","hasSW","protocol","hostname","serviceWorker","register","applicationCache","directory","doLoad","page","iframe","appCacheIframe","applyUpdate","errback","applyMiddleware","middlewares","_dispatch","chain","middlewareAPI","middleware","_compose2","_extends","_compose","bindActionCreator","actionCreator","bindActionCreators","actionCreators","boundActionCreators","getUndefinedStateErrorMessage","actionType","actionName","assertReducerSanity","reducers","_createStore","random","combineReducers","reducerKeys","finalReducers","sanityError","finalReducerKeys","hasChanged","nextState","previousStateForKey","nextStateForKey","errorMessage","_warning","_createStore2","_combineReducers","_combineReducers2","_bindActionCreators","_bindActionCreators2","_applyMiddleware","_applyMiddleware2","__webpack_amd_options__","webpackContext","webpackContextResolve","./app.tag","./footer.tag","./header/category.tag","./header/header.tag","./item.tag"],"mappings":"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","file":"bundle.2190dd243d3bc467abd9.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ((function(modules) {\n\t// Check all modules for deduplicated modules\n\tfor(var i in modules) {\n\t\tif(Object.prototype.hasOwnProperty.call(modules, i)) {\n\t\t\tswitch(typeof modules[i]) {\n\t\t\tcase \"function\": break;\n\t\t\tcase \"object\":\n\t\t\t\t// Module can be created from a template\n\t\t\t\tmodules[i] = (function(_m) {\n\t\t\t\t\tvar args = _m.slice(1), fn = modules[_m[0]];\n\t\t\t\t\treturn function (a,b,c) {\n\t\t\t\t\t\tfn.apply(this, [a,b,c].concat(args));\n\t\t\t\t\t};\n\t\t\t\t}(modules[i]));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Module is a copy of another module\n\t\t\t\tmodules[i] = modules[modules[i]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn modules;\n}([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\t__webpack_require__(15);\n\t\n\t__webpack_require__(16);\n\t\n\t__webpack_require__(17);\n\t\n\twindow.SERVICE_URL =  false ? 'http://localhost:8080' : '';\n\tif (true) {\n\t  __webpack_require__(22).install();\n\t}\n\t\n\t// Require all tags\n\tvar req = __webpack_require__(30);\n\treq.keys().forEach(function (key) {\n\t  return req(key);\n\t});\n\t\n\tvar store = __webpack_require__(11);\n\tvar colorchart = __webpack_require__(13)();\n\t\n\tdocument.addEventListener('DOMContentLoaded', function () {\n\t  riot.mount('*', {\n\t    store: store,\n\t    colorchart: colorchart\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* Riot v2.4.1, @license MIT */\n\t\n\t;(function(window, undefined) {\n\t  'use strict';\n\tvar riot = { version: 'v2.4.1', settings: {} },\n\t  // be aware, internal usage\n\t  // ATTENTION: prefix the global dynamic variables with `__`\n\t\n\t  // counter to give a unique id to all the Tag instances\n\t  __uid = 0,\n\t  // tags instances cache\n\t  __virtualDom = [],\n\t  // tags implementation cache\n\t  __tagImpl = {},\n\t\n\t  /**\n\t   * Const\n\t   */\n\t  GLOBAL_MIXIN = '__global_mixin',\n\t\n\t  // riot specific prefixes\n\t  RIOT_PREFIX = 'riot-',\n\t  RIOT_TAG = RIOT_PREFIX + 'tag',\n\t  RIOT_TAG_IS = 'data-is',\n\t\n\t  // for typeof == '' comparisons\n\t  T_STRING = 'string',\n\t  T_OBJECT = 'object',\n\t  T_UNDEF  = 'undefined',\n\t  T_FUNCTION = 'function',\n\t  // special native tags that cannot be treated like the others\n\t  SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n\t  RESERVED_WORDS_BLACKLIST = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|parent|opts|trigger|o(?:n|ff|ne))$/,\n\t  // SVG tags list https://www.w3.org/TR/SVG/attindex.html#PresentationAttributes\n\t  SVG_TAGS_LIST = ['altGlyph', 'animate', 'animateColor', 'circle', 'clipPath', 'defs', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feGaussianBlur', 'feImage', 'feMerge', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence', 'filter', 'font', 'foreignObject', 'g', 'glyph', 'glyphRef', 'image', 'line', 'linearGradient', 'marker', 'mask', 'missing-glyph', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'switch', 'symbol', 'text', 'textPath', 'tref', 'tspan', 'use'],\n\t\n\t  // version# for IE 8-11, 0 for others\n\t  IE_VERSION = (window && window.document || {}).documentMode | 0,\n\t\n\t  // detect firefox to fix #1374\n\t  FIREFOX = window && !!window.InstallTrigger\n\t/* istanbul ignore next */\n\triot.observable = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {}\n\t\n\t  /**\n\t   * Private variables\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice\n\t\n\t  /**\n\t   * Private Methods\n\t   */\n\t\n\t  /**\n\t   * Helper function needed to get and loop all the events in a string\n\t   * @param   { String }   e - event string\n\t   * @param   {Function}   fn - callback\n\t   */\n\t  function onEachEvent(e, fn) {\n\t    var es = e.split(' '), l = es.length, i = 0, name, indx\n\t    for (; i < l; i++) {\n\t      name = es[i]\n\t      indx = name.indexOf('.')\n\t      if (name) fn( ~indx ? name.substring(0, indx) : name, i, ~indx ? name.slice(indx + 1) : null)\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Public Api\n\t   */\n\t\n\t  // extend the el object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given space separated list of `events` and\n\t     * execute the `callback` each time an event is triggered.\n\t     * @param  { String } events - events ids\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(events, fn) {\n\t        if (typeof fn != 'function')  return el\n\t\n\t        onEachEvent(events, function(name, pos, ns) {\n\t          (callbacks[name] = callbacks[name] || []).push(fn)\n\t          fn.typed = pos > 0\n\t          fn.ns = ns\n\t        })\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given space separated list of `events` listeners\n\t     * @param   { String } events - events ids\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(events, fn) {\n\t        if (events == '*' && !fn) callbacks = {}\n\t        else {\n\t          onEachEvent(events, function(name, pos, ns) {\n\t            if (fn || ns) {\n\t              var arr = callbacks[name]\n\t              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t                if (cb == fn || ns && cb.ns == ns) arr.splice(i--, 1)\n\t              }\n\t            } else delete callbacks[name]\n\t          })\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given space separated list of `events` and\n\t     * execute the `callback` at most once\n\t     * @param   { String } events - events ids\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(events, fn) {\n\t        function on() {\n\t          el.off(events, on)\n\t          fn.apply(el, arguments)\n\t        }\n\t        return el.on(events, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to\n\t     * the given space separated list of `events`\n\t     * @param   { String } events - events ids\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(events) {\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns\n\t\n\t        for (var i = 0; i < arglen; i++) {\n\t          args[i] = arguments[i + 1] // skip first argument\n\t        }\n\t\n\t        onEachEvent(events, function(name, pos, ns) {\n\t\n\t          fns = slice.call(callbacks[name] || [], 0)\n\t\n\t          for (var i = 0, fn; fn = fns[i]; ++i) {\n\t            if (fn.busy) continue\n\t            fn.busy = 1\n\t            if (!ns || fn.ns == ns) fn.apply(el, fn.typed ? [name].concat(args) : args)\n\t            if (fns[i] !== fn) { i-- }\n\t            fn.busy = 0\n\t          }\n\t\n\t          if (callbacks['*'] && name != '*')\n\t            el.trigger.apply(el, ['*', name].concat(args))\n\t\n\t        })\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  })\n\t\n\t  return el\n\t\n\t}\n\t/* istanbul ignore next */\n\t;(function(riot) {\n\t\n\t/**\n\t * Simple client-side router\n\t * @module riot-route\n\t */\n\t\n\t\n\tvar RE_ORIGIN = /^.+?\\/\\/+[^\\/]+/,\n\t  EVENT_LISTENER = 'EventListener',\n\t  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n\t  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n\t  HAS_ATTRIBUTE = 'hasAttribute',\n\t  REPLACE = 'replace',\n\t  POPSTATE = 'popstate',\n\t  HASHCHANGE = 'hashchange',\n\t  TRIGGER = 'trigger',\n\t  MAX_EMIT_STACK_LEVEL = 3,\n\t  win = typeof window != 'undefined' && window,\n\t  doc = typeof document != 'undefined' && document,\n\t  hist = win && history,\n\t  loc = win && (hist.location || win.location), // see html5-history-api\n\t  prot = Router.prototype, // to minify more\n\t  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n\t  started = false,\n\t  central = riot.observable(),\n\t  routeFound = false,\n\t  debouncedEmit,\n\t  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\t\n\t/**\n\t * Default parser. You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_PARSER(path) {\n\t  return path.split(/[/?#]/)\n\t}\n\t\n\t/**\n\t * Default parser (second). You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @param {string} filter - filter string (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_SECOND_PARSER(path, filter) {\n\t  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n\t    args = path.match(re)\n\t\n\t  if (args) return args.slice(1)\n\t}\n\t\n\t/**\n\t * Simple/cheap debounce implementation\n\t * @param   {function} fn - callback\n\t * @param   {number} delay - delay in seconds\n\t * @returns {function} debounced function\n\t */\n\tfunction debounce(fn, delay) {\n\t  var t\n\t  return function () {\n\t    clearTimeout(t)\n\t    t = setTimeout(fn, delay)\n\t  }\n\t}\n\t\n\t/**\n\t * Set the window listeners to trigger the routes\n\t * @param {boolean} autoExec - see route.start\n\t */\n\tfunction start(autoExec) {\n\t  debouncedEmit = debounce(emit, 1)\n\t  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n\t  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n\t  doc[ADD_EVENT_LISTENER](clickEvent, click)\n\t  if (autoExec) emit(true)\n\t}\n\t\n\t/**\n\t * Router class\n\t */\n\tfunction Router() {\n\t  this.$ = []\n\t  riot.observable(this) // make it observable\n\t  central.on('stop', this.s.bind(this))\n\t  central.on('emit', this.e.bind(this))\n\t}\n\t\n\tfunction normalize(path) {\n\t  return path[REPLACE](/^\\/|\\/$/, '')\n\t}\n\t\n\tfunction isString(str) {\n\t  return typeof str == 'string'\n\t}\n\t\n\t/**\n\t * Get the part after domain name\n\t * @param {string} href - fullpath\n\t * @returns {string} path from root\n\t */\n\tfunction getPathFromRoot(href) {\n\t  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n\t}\n\t\n\t/**\n\t * Get the part after base\n\t * @param {string} href - fullpath\n\t * @returns {string} path from base\n\t */\n\tfunction getPathFromBase(href) {\n\t  return base[0] == '#'\n\t    ? (href || loc.href || '').split(base)[1] || ''\n\t    : (loc ? getPathFromRoot(href) : href || '')[REPLACE](base, '')\n\t}\n\t\n\tfunction emit(force) {\n\t  // the stack is needed for redirections\n\t  var isRoot = emitStackLevel == 0\n\t  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\t\n\t  emitStackLevel++\n\t  emitStack.push(function() {\n\t    var path = getPathFromBase()\n\t    if (force || path != current) {\n\t      central[TRIGGER]('emit', path)\n\t      current = path\n\t    }\n\t  })\n\t  if (isRoot) {\n\t    while (emitStack.length) {\n\t      emitStack[0]()\n\t      emitStack.shift()\n\t    }\n\t    emitStackLevel = 0\n\t  }\n\t}\n\t\n\tfunction click(e) {\n\t  if (\n\t    e.which != 1 // not left click\n\t    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n\t    || e.defaultPrevented // or default prevented\n\t  ) return\n\t\n\t  var el = e.target\n\t  while (el && el.nodeName != 'A') el = el.parentNode\n\t\n\t  if (\n\t    !el || el.nodeName != 'A' // not A tag\n\t    || el[HAS_ATTRIBUTE]('download') // has download attr\n\t    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n\t    || el.target && el.target != '_self' // another window or frame\n\t    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n\t  ) return\n\t\n\t  if (el.href != loc.href) {\n\t    if (\n\t      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n\t      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n\t      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n\t    ) return\n\t  }\n\t\n\t  e.preventDefault()\n\t}\n\t\n\t/**\n\t * Go to the path\n\t * @param {string} path - destination path\n\t * @param {string} title - page title\n\t * @param {boolean} shouldReplace - use replaceState or pushState\n\t * @returns {boolean} - route not found flag\n\t */\n\tfunction go(path, title, shouldReplace) {\n\t  if (hist) { // if a browser\n\t    path = base + normalize(path)\n\t    title = title || doc.title\n\t    // browsers ignores the second parameter `title`\n\t    shouldReplace\n\t      ? hist.replaceState(null, title, path)\n\t      : hist.pushState(null, title, path)\n\t    // so we need to set it manually\n\t    doc.title = title\n\t    routeFound = false\n\t    emit()\n\t    return routeFound\n\t  }\n\t\n\t  // Server-side usage: directly execute handlers for the path\n\t  return central[TRIGGER]('emit', getPathFromBase(path))\n\t}\n\t\n\t/**\n\t * Go to path or set action\n\t * a single string:                go there\n\t * two strings:                    go there with setting a title\n\t * two strings and boolean:        replace history with setting a title\n\t * a single function:              set an action on the default route\n\t * a string/RegExp and a function: set an action on the route\n\t * @param {(string|function)} first - path / action / filter\n\t * @param {(string|RegExp|function)} second - title / action\n\t * @param {boolean} third - replace flag\n\t */\n\tprot.m = function(first, second, third) {\n\t  if (isString(first) && (!second || isString(second))) go(first, second, third || false)\n\t  else if (second) this.r(first, second)\n\t  else this.r('@', first)\n\t}\n\t\n\t/**\n\t * Stop routing\n\t */\n\tprot.s = function() {\n\t  this.off('*')\n\t  this.$ = []\n\t}\n\t\n\t/**\n\t * Emit\n\t * @param {string} path - path\n\t */\n\tprot.e = function(path) {\n\t  this.$.concat('@').some(function(filter) {\n\t    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n\t    if (typeof args != 'undefined') {\n\t      this[TRIGGER].apply(null, [filter].concat(args))\n\t      return routeFound = true // exit from loop\n\t    }\n\t  }, this)\n\t}\n\t\n\t/**\n\t * Register route\n\t * @param {string} filter - filter for matching to url\n\t * @param {function} action - action to register\n\t */\n\tprot.r = function(filter, action) {\n\t  if (filter != '@') {\n\t    filter = '/' + normalize(filter)\n\t    this.$.push(filter)\n\t  }\n\t  this.on(filter, action)\n\t}\n\t\n\tvar mainRouter = new Router()\n\tvar route = mainRouter.m.bind(mainRouter)\n\t\n\t/**\n\t * Create a sub router\n\t * @returns {function} the method of a new Router object\n\t */\n\troute.create = function() {\n\t  var newSubRouter = new Router()\n\t  // assign sub-router's main method\n\t  var router = newSubRouter.m.bind(newSubRouter)\n\t  // stop only this sub-router\n\t  router.stop = newSubRouter.s.bind(newSubRouter)\n\t  return router\n\t}\n\t\n\t/**\n\t * Set the base of url\n\t * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n\t */\n\troute.base = function(arg) {\n\t  base = arg || '#'\n\t  current = getPathFromBase() // recalculate current path\n\t}\n\t\n\t/** Exec routing right now **/\n\troute.exec = function() {\n\t  emit(true)\n\t}\n\t\n\t/**\n\t * Replace the default router to yours\n\t * @param {function} fn - your parser function\n\t * @param {function} fn2 - your secondParser function\n\t */\n\troute.parser = function(fn, fn2) {\n\t  if (!fn && !fn2) {\n\t    // reset parser for testing...\n\t    parser = DEFAULT_PARSER\n\t    secondParser = DEFAULT_SECOND_PARSER\n\t  }\n\t  if (fn) parser = fn\n\t  if (fn2) secondParser = fn2\n\t}\n\t\n\t/**\n\t * Helper function to get url query as an object\n\t * @returns {object} parsed query\n\t */\n\troute.query = function() {\n\t  var q = {}\n\t  var href = loc.href || current\n\t  href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n\t  return q\n\t}\n\t\n\t/** Stop routing **/\n\troute.stop = function () {\n\t  if (started) {\n\t    if (win) {\n\t      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n\t      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n\t      doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n\t    }\n\t    central[TRIGGER]('stop')\n\t    started = false\n\t  }\n\t}\n\t\n\t/**\n\t * Start routing\n\t * @param {boolean} autoExec - automatically exec after starting if true\n\t */\n\troute.start = function (autoExec) {\n\t  if (!started) {\n\t    if (win) {\n\t      if (document.readyState == 'complete') start(autoExec)\n\t      // the timeout is needed to solve\n\t      // a weird safari bug https://github.com/riot/route/issues/33\n\t      else win[ADD_EVENT_LISTENER]('load', function() {\n\t        setTimeout(function() { start(autoExec) }, 1)\n\t      })\n\t    }\n\t    started = true\n\t  }\n\t}\n\t\n\t/** Prepare the router **/\n\troute.base()\n\troute.parser()\n\t\n\triot.route = route\n\t})(riot)\n\t/* istanbul ignore next */\n\t\n\t/**\n\t * The riot template engine\n\t * @version v2.4.0\n\t */\n\t/**\n\t * riot.util.brackets\n\t *\n\t * - `brackets    ` - Returns a string or regex based on its parameter\n\t * - `brackets.set` - Change the current riot brackets\n\t *\n\t * @module\n\t */\n\t\n\tvar brackets = (function (UNDEF) {\n\t\n\t  var\n\t    REGLOB = 'g',\n\t\n\t    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\t\n\t    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\t\n\t    S_QBLOCKS = R_STRINGS.source + '|' +\n\t      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n\t      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\t\n\t    FINDBRACES = {\n\t      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n\t      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n\t      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n\t    },\n\t\n\t    DEFAULT = '{ }'\n\t\n\t  var _pairs = [\n\t    '{', '}',\n\t    '{', '}',\n\t    /{[^}]*}/,\n\t    /\\\\([{}])/g,\n\t    /\\\\({)|{/g,\n\t    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n\t    DEFAULT,\n\t    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n\t    /(^|[^\\\\]){=[\\S\\s]*?}/\n\t  ]\n\t\n\t  var\n\t    cachedBrackets = UNDEF,\n\t    _regex,\n\t    _cache = [],\n\t    _settings\n\t\n\t  function _loopback (re) { return re }\n\t\n\t  function _rewrite (re, bp) {\n\t    if (!bp) bp = _cache\n\t    return new RegExp(\n\t      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n\t    )\n\t  }\n\t\n\t  function _create (pair) {\n\t    if (pair === DEFAULT) return _pairs\n\t\n\t    var arr = pair.split(' ')\n\t\n\t    if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) { // eslint-disable-line\n\t      throw new Error('Unsupported brackets \"' + pair + '\"')\n\t    }\n\t    arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n\t\n\t    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr)\n\t    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr)\n\t    arr[6] = _rewrite(_pairs[6], arr)\n\t    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB)\n\t    arr[8] = pair\n\t    return arr\n\t  }\n\t\n\t  function _brackets (reOrIdx) {\n\t    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n\t  }\n\t\n\t  _brackets.split = function split (str, tmpl, _bp) {\n\t    // istanbul ignore next: _bp is for the compiler\n\t    if (!_bp) _bp = _cache\n\t\n\t    var\n\t      parts = [],\n\t      match,\n\t      isexpr,\n\t      start,\n\t      pos,\n\t      re = _bp[6]\n\t\n\t    isexpr = start = re.lastIndex = 0\n\t\n\t    while ((match = re.exec(str))) {\n\t\n\t      pos = match.index\n\t\n\t      if (isexpr) {\n\t\n\t        if (match[2]) {\n\t          re.lastIndex = skipBraces(str, match[2], re.lastIndex)\n\t          continue\n\t        }\n\t        if (!match[3]) {\n\t          continue\n\t        }\n\t      }\n\t\n\t      if (!match[1]) {\n\t        unescapeStr(str.slice(start, pos))\n\t        start = re.lastIndex\n\t        re = _bp[6 + (isexpr ^= 1)]\n\t        re.lastIndex = start\n\t      }\n\t    }\n\t\n\t    if (str && start < str.length) {\n\t      unescapeStr(str.slice(start))\n\t    }\n\t\n\t    return parts\n\t\n\t    function unescapeStr (s) {\n\t      if (tmpl || isexpr) {\n\t        parts.push(s && s.replace(_bp[5], '$1'))\n\t      } else {\n\t        parts.push(s)\n\t      }\n\t    }\n\t\n\t    function skipBraces (s, ch, ix) {\n\t      var\n\t        match,\n\t        recch = FINDBRACES[ch]\n\t\n\t      recch.lastIndex = ix\n\t      ix = 1\n\t      while ((match = recch.exec(s))) {\n\t        if (match[1] &&\n\t          !(match[1] === ch ? ++ix : --ix)) break\n\t      }\n\t      return ix ? s.length : recch.lastIndex\n\t    }\n\t  }\n\t\n\t  _brackets.hasExpr = function hasExpr (str) {\n\t    return _cache[4].test(str)\n\t  }\n\t\n\t  _brackets.loopKeys = function loopKeys (expr) {\n\t    var m = expr.match(_cache[9])\n\t\n\t    return m\n\t      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n\t      : { val: expr.trim() }\n\t  }\n\t\n\t  _brackets.array = function array (pair) {\n\t    return pair ? _create(pair) : _cache\n\t  }\n\t\n\t  function _reset (pair) {\n\t    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n\t      _cache = _create(pair)\n\t      _regex = pair === DEFAULT ? _loopback : _rewrite\n\t      _cache[9] = _regex(_pairs[9])\n\t    }\n\t    cachedBrackets = pair\n\t  }\n\t\n\t  function _setSettings (o) {\n\t    var b\n\t\n\t    o = o || {}\n\t    b = o.brackets\n\t    Object.defineProperty(o, 'brackets', {\n\t      set: _reset,\n\t      get: function () { return cachedBrackets },\n\t      enumerable: true\n\t    })\n\t    _settings = o\n\t    _reset(b)\n\t  }\n\t\n\t  Object.defineProperty(_brackets, 'settings', {\n\t    set: _setSettings,\n\t    get: function () { return _settings }\n\t  })\n\t\n\t  /* istanbul ignore next: in the browser riot is always in the scope */\n\t  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n\t  _brackets.set = _reset\n\t\n\t  _brackets.R_STRINGS = R_STRINGS\n\t  _brackets.R_MLCOMMS = R_MLCOMMS\n\t  _brackets.S_QBLOCKS = S_QBLOCKS\n\t\n\t  return _brackets\n\t\n\t})()\n\t\n\t/**\n\t * @module tmpl\n\t *\n\t * tmpl          - Root function, returns the template value, render with data\n\t * tmpl.hasExpr  - Test the existence of a expression inside a string\n\t * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n\t */\n\t\n\tvar tmpl = (function () {\n\t\n\t  var _cache = {}\n\t\n\t  function _tmpl (str, data) {\n\t    if (!str) return str\n\t\n\t    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n\t  }\n\t\n\t  _tmpl.haveRaw = brackets.hasRaw\n\t\n\t  _tmpl.hasExpr = brackets.hasExpr\n\t\n\t  _tmpl.loopKeys = brackets.loopKeys\n\t\n\t  _tmpl.errorHandler = null\n\t\n\t  function _logErr (err, ctx) {\n\t\n\t    if (_tmpl.errorHandler) {\n\t\n\t      err.riotData = {\n\t        tagName: ctx && ctx.root && ctx.root.tagName,\n\t        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n\t      }\n\t      _tmpl.errorHandler(err)\n\t    }\n\t  }\n\t\n\t  function _create (str) {\n\t    var expr = _getTmpl(str)\n\t\n\t    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\t\n\t/* eslint-disable */\n\t\n\t    return new Function('E', expr + ';')\n\t/* eslint-enable */\n\t  }\n\t\n\t  var\n\t    CH_IDEXPR = '\\u2057',\n\t    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n\t    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n\t    RE_DQUOTE = /\\u2057/g,\n\t    RE_QBMARK = /\\u2057(\\d+)~/g\n\t\n\t  function _getTmpl (str) {\n\t    var\n\t      qstr = [],\n\t      expr,\n\t      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1)\n\t\n\t    if (parts.length > 2 || parts[0]) {\n\t      var i, j, list = []\n\t\n\t      for (i = j = 0; i < parts.length; ++i) {\n\t\n\t        expr = parts[i]\n\t\n\t        if (expr && (expr = i & 1\n\t\n\t            ? _parseExpr(expr, 1, qstr)\n\t\n\t            : '\"' + expr\n\t                .replace(/\\\\/g, '\\\\\\\\')\n\t                .replace(/\\r\\n?|\\n/g, '\\\\n')\n\t                .replace(/\"/g, '\\\\\"') +\n\t              '\"'\n\t\n\t          )) list[j++] = expr\n\t\n\t      }\n\t\n\t      expr = j < 2 ? list[0]\n\t           : '[' + list.join(',') + '].join(\"\")'\n\t\n\t    } else {\n\t\n\t      expr = _parseExpr(parts[1], 0, qstr)\n\t    }\n\t\n\t    if (qstr[0]) {\n\t      expr = expr.replace(RE_QBMARK, function (_, pos) {\n\t        return qstr[pos]\n\t          .replace(/\\r/g, '\\\\r')\n\t          .replace(/\\n/g, '\\\\n')\n\t      })\n\t    }\n\t    return expr\n\t  }\n\t\n\t  var\n\t    RE_BREND = {\n\t      '(': /[()]/g,\n\t      '[': /[[\\]]/g,\n\t      '{': /[{}]/g\n\t    }\n\t\n\t  function _parseExpr (expr, asText, qstr) {\n\t\n\t    expr = expr\n\t          .replace(RE_QBLOCK, function (s, div) {\n\t            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n\t          })\n\t          .replace(/\\s+/g, ' ').trim()\n\t          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\t\n\t    if (expr) {\n\t      var\n\t        list = [],\n\t        cnt = 0,\n\t        match\n\t\n\t      while (expr &&\n\t            (match = expr.match(RE_CSNAME)) &&\n\t            !match.index\n\t        ) {\n\t        var\n\t          key,\n\t          jsb,\n\t          re = /,|([[{(])|$/g\n\t\n\t        expr = RegExp.rightContext\n\t        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\t\n\t        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\t\n\t        jsb  = expr.slice(0, match.index)\n\t        expr = RegExp.rightContext\n\t\n\t        list[cnt++] = _wrapExpr(jsb, 1, key)\n\t      }\n\t\n\t      expr = !cnt ? _wrapExpr(expr, asText)\n\t           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n\t    }\n\t    return expr\n\t\n\t    function skipBraces (ch, re) {\n\t      var\n\t        mm,\n\t        lv = 1,\n\t        ir = RE_BREND[ch]\n\t\n\t      ir.lastIndex = re.lastIndex\n\t      while (mm = ir.exec(expr)) {\n\t        if (mm[0] === ch) ++lv\n\t        else if (!--lv) break\n\t      }\n\t      re.lastIndex = lv ? expr.length : ir.lastIndex\n\t    }\n\t  }\n\t\n\t  // istanbul ignore next: not both\n\t  var // eslint-disable-next-line max-len\n\t    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n\t    JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n\t    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/\n\t\n\t  function _wrapExpr (expr, asText, key) {\n\t    var tb\n\t\n\t    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n\t      if (mvar) {\n\t        pos = tb ? 0 : pos + match.length\n\t\n\t        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n\t          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n\t          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n\t        } else if (pos) {\n\t          tb = !JS_NOPROPS.test(s.slice(pos))\n\t        }\n\t      }\n\t      return match\n\t    })\n\t\n\t    if (tb) {\n\t      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n\t    }\n\t\n\t    if (key) {\n\t\n\t      expr = (tb\n\t          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n\t        ) + '?\"' + key + '\":\"\"'\n\t\n\t    } else if (asText) {\n\t\n\t      expr = 'function(v){' + (tb\n\t          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n\t        ) + ';return v||v===0?v:\"\"}.call(this)'\n\t    }\n\t\n\t    return expr\n\t  }\n\t\n\t  // istanbul ignore next: compatibility fix for beta versions\n\t  _tmpl.parse = function (s) { return s }\n\t\n\t  _tmpl.version = brackets.version = 'v2.4.0'\n\t\n\t  return _tmpl\n\t\n\t})()\n\t\n\t/*\n\t  lib/browser/tag/mkdom.js\n\t\n\t  Includes hacks needed for the Internet Explorer version 9 and below\n\t  See: http://kangax.github.io/compat-table/es5/#ie8\n\t       http://codeplanet.io/dropping-ie8/\n\t*/\n\tvar mkdom = (function _mkdom() {\n\t  var\n\t    reHasYield  = /<yield\\b/i,\n\t    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n\t    reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n\t    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig\n\t  var\n\t    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n\t    tblTags = IE_VERSION && IE_VERSION < 10\n\t      ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/\n\t\n\t  /**\n\t   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n\t   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n\t   *\n\t   * @param   {string} templ  - The template coming from the custom tag definition\n\t   * @param   {string} [html] - HTML content that comes from the DOM element where you\n\t   *           will mount the tag, mostly the original tag in the page\n\t   * @returns {HTMLElement} DOM element with _templ_ merged through `YIELD` with the _html_.\n\t   */\n\t  function _mkdom(templ, html) {\n\t    var\n\t      match   = templ && templ.match(/^\\s*<([-\\w]+)/),\n\t      tagName = match && match[1].toLowerCase(),\n\t      el = mkEl('div', isSVGTag(tagName))\n\t\n\t    // replace all the yield tags with the tag inner html\n\t    templ = replaceYield(templ, html)\n\t\n\t    /* istanbul ignore next */\n\t    if (tblTags.test(tagName))\n\t      el = specialTags(el, templ, tagName)\n\t    else\n\t      setInnerHTML(el, templ)\n\t\n\t    el.stub = true\n\t\n\t    return el\n\t  }\n\t\n\t  /*\n\t    Creates the root element for table or select child elements:\n\t    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n\t  */\n\t  function specialTags(el, templ, tagName) {\n\t    var\n\t      select = tagName[0] === 'o',\n\t      parent = select ? 'select>' : 'table>'\n\t\n\t    // trim() is important here, this ensures we don't have artifacts,\n\t    // so we can check if we have only one element inside the parent\n\t    el.innerHTML = '<' + parent + templ.trim() + '</' + parent\n\t    parent = el.firstChild\n\t\n\t    // returns the immediate parent if tr/th/td/col is the only element, if not\n\t    // returns the whole tree, as this can include additional elements\n\t    if (select) {\n\t      parent.selectedIndex = -1  // for IE9, compatible w/current riot behavior\n\t    } else {\n\t      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n\t      var tname = rootEls[tagName]\n\t      if (tname && parent.childElementCount === 1) parent = $(tname, parent)\n\t    }\n\t    return parent\n\t  }\n\t\n\t  /*\n\t    Replace the yield tag from any tag template with the innerHTML of the\n\t    original tag in the page\n\t  */\n\t  function replaceYield(templ, html) {\n\t    // do nothing if no yield\n\t    if (!reHasYield.test(templ)) return templ\n\t\n\t    // be careful with #1343 - string on the source having `$1`\n\t    var src = {}\n\t\n\t    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n\t      src[ref] = src[ref] || text   // preserve first definition\n\t      return ''\n\t    }).trim()\n\t\n\t    return templ\n\t      .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n\t        return src[ref] || def || ''\n\t      })\n\t      .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n\t        return html || def || ''\n\t      })\n\t  }\n\t\n\t  return _mkdom\n\t\n\t})()\n\t\n\t/**\n\t * Convert the item looped into an object used to extend the child tag properties\n\t * @param   { Object } expr - object containing the keys used to extend the children tags\n\t * @param   { * } key - value to assign to the new object returned\n\t * @param   { * } val - value containing the position of the item in the array\n\t * @returns { Object } - new object containing the values of the original item\n\t *\n\t * The variables 'key' and 'val' are arbitrary.\n\t * They depend on the collection type looped (Array, Object)\n\t * and on the expression used on the each tag\n\t *\n\t */\n\tfunction mkitem(expr, key, val) {\n\t  var item = {}\n\t  item[expr.key] = key\n\t  if (expr.pos) item[expr.pos] = val\n\t  return item\n\t}\n\t\n\t/**\n\t * Unmount the redundant tags\n\t * @param   { Array } items - array containing the current items to loop\n\t * @param   { Array } tags - array containing all the children tags\n\t */\n\tfunction unmountRedundant(items, tags) {\n\t\n\t  var i = tags.length,\n\t    j = items.length,\n\t    t\n\t\n\t  while (i > j) {\n\t    t = tags[--i]\n\t    tags.splice(i, 1)\n\t    t.unmount()\n\t  }\n\t}\n\t\n\t/**\n\t * Move the nested custom tags in non custom loop tags\n\t * @param   { Object } child - non custom loop tag\n\t * @param   { Number } i - current position of the loop tag\n\t */\n\tfunction moveNestedTags(child, i) {\n\t  Object.keys(child.tags).forEach(function(tagName) {\n\t    var tag = child.tags[tagName]\n\t    if (isArray(tag))\n\t      each(tag, function (t) {\n\t        moveChildTag(t, tagName, i)\n\t      })\n\t    else\n\t      moveChildTag(tag, tagName, i)\n\t  })\n\t}\n\t\n\t/**\n\t * Adds the elements for a virtual tag\n\t * @param { Tag } tag - the tag whose root's children will be inserted or appended\n\t * @param { Node } src - the node that will do the inserting or appending\n\t * @param { Tag } target - only if inserting, insert before this tag's first child\n\t */\n\tfunction addVirtual(tag, src, target) {\n\t  var el = tag._root, sib\n\t  tag._virts = []\n\t  while (el) {\n\t    sib = el.nextSibling\n\t    if (target)\n\t      src.insertBefore(el, target._root)\n\t    else\n\t      src.appendChild(el)\n\t\n\t    tag._virts.push(el) // hold for unmounting\n\t    el = sib\n\t  }\n\t}\n\t\n\t/**\n\t * Move virtual tag and all child nodes\n\t * @param { Tag } tag - first child reference used to start move\n\t * @param { Node } src  - the node that will do the inserting\n\t * @param { Tag } target - insert before this tag's first child\n\t * @param { Number } len - how many child nodes to move\n\t */\n\tfunction moveVirtual(tag, src, target, len) {\n\t  var el = tag._root, sib, i = 0\n\t  for (; i < len; i++) {\n\t    sib = el.nextSibling\n\t    src.insertBefore(el, target._root)\n\t    el = sib\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Manage tags having the 'each'\n\t * @param   { Object } dom - DOM node we need to loop\n\t * @param   { Tag } parent - parent tag instance where the dom node is contained\n\t * @param   { String } expr - string contained in the 'each' attribute\n\t */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  // remove the each property from the original tag\n\t  remAttr(dom, 'each')\n\t\n\t  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n\t    tagName = getTagName(dom),\n\t    impl = __tagImpl[tagName] || { tmpl: getOuterHTML(dom) },\n\t    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n\t    root = dom.parentNode,\n\t    ref = document.createTextNode(''),\n\t    child = getTag(dom),\n\t    isOption = tagName.toLowerCase() === 'option', // the option tags must be treated differently\n\t    tags = [],\n\t    oldItems = [],\n\t    hasKeys,\n\t    isVirtual = dom.tagName == 'VIRTUAL'\n\t\n\t  // parse the each expression\n\t  expr = tmpl.loopKeys(expr)\n\t\n\t  // insert a marked where the loop tags will be injected\n\t  root.insertBefore(ref, dom)\n\t\n\t  // clean template code\n\t  parent.one('before-mount', function () {\n\t\n\t    // remove the original DOM node\n\t    dom.parentNode.removeChild(dom)\n\t    if (root.stub) root = parent.root\n\t\n\t  }).on('update', function () {\n\t    // get the new items collection\n\t    var items = tmpl(expr.val, parent),\n\t      // create a fragment to hold the new DOM nodes to inject in the parent tag\n\t      frag = document.createDocumentFragment()\n\t\n\t    // object loop. any changes cause full redraw\n\t    if (!isArray(items)) {\n\t      hasKeys = items || false\n\t      items = hasKeys ?\n\t        Object.keys(items).map(function (key) {\n\t          return mkitem(expr, key, items[key])\n\t        }) : []\n\t    }\n\t\n\t    // loop all the new items\n\t    var i = 0,\n\t      itemsLength = items.length\n\t\n\t    for (; i < itemsLength; i++) {\n\t      // reorder only if the items are objects\n\t      var\n\t        item = items[i],\n\t        _mustReorder = mustReorder && typeof item == T_OBJECT && !hasKeys,\n\t        oldPos = oldItems.indexOf(item),\n\t        pos = ~oldPos && _mustReorder ? oldPos : i,\n\t        // does a tag exist in this position?\n\t        tag = tags[pos]\n\t\n\t      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\t\n\t      // new tag\n\t      if (\n\t        !_mustReorder && !tag // with no-reorder we just update the old tags\n\t        ||\n\t        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n\t      ) {\n\t\n\t        tag = new Tag(impl, {\n\t          parent: parent,\n\t          isLoop: true,\n\t          hasImpl: !!__tagImpl[tagName],\n\t          root: useRoot ? root : dom.cloneNode(),\n\t          item: item\n\t        }, dom.innerHTML)\n\t\n\t        tag.mount()\n\t\n\t        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n\t        // this tag must be appended\n\t        if (i == tags.length || !tags[i]) { // fix 1581\n\t          if (isVirtual)\n\t            addVirtual(tag, frag)\n\t          else frag.appendChild(tag.root)\n\t        }\n\t        // this tag must be insert\n\t        else {\n\t          if (isVirtual)\n\t            addVirtual(tag, root, tags[i])\n\t          else root.insertBefore(tag.root, tags[i].root) // #1374 some browsers reset selected here\n\t          oldItems.splice(i, 0, item)\n\t        }\n\t\n\t        tags.splice(i, 0, tag)\n\t        pos = i // handled here so no move\n\t      } else tag.update(item, true)\n\t\n\t      // reorder the tag if it's not located in its previous position\n\t      if (\n\t        pos !== i && _mustReorder &&\n\t        tags[i] // fix 1581 unable to reproduce it in a test!\n\t      ) {\n\t        // update the DOM\n\t        if (isVirtual)\n\t          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n\t        else root.insertBefore(tag.root, tags[i].root)\n\t        // update the position attribute if it exists\n\t        if (expr.pos)\n\t          tag[expr.pos] = i\n\t        // move the old tag instance\n\t        tags.splice(i, 0, tags.splice(pos, 1)[0])\n\t        // move the old item\n\t        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n\t        // if the loop tags are not custom\n\t        // we need to move all their custom tags into the right position\n\t        if (!child && tag.tags) moveNestedTags(tag, i)\n\t      }\n\t\n\t      // cache the original item to use it in the events bound to this node\n\t      // and its children\n\t      tag._item = item\n\t      // cache the real parent tag internally\n\t      defineProperty(tag, '_parent', parent)\n\t    }\n\t\n\t    // remove the redundant tags\n\t    unmountRedundant(items, tags)\n\t\n\t    // insert the new nodes\n\t    if (isOption) {\n\t      root.appendChild(frag)\n\t\n\t      // #1374 FireFox bug in <option selected={expression}>\n\t      if (FIREFOX && !root.multiple) {\n\t        for (var n = 0; n < root.length; n++) {\n\t          if (root[n].__riot1374) {\n\t            root.selectedIndex = n  // clear other options\n\t            delete root[n].__riot1374\n\t            break\n\t          }\n\t        }\n\t      }\n\t    }\n\t    else root.insertBefore(frag, ref)\n\t\n\t    // set the 'tags' property of the parent tag\n\t    // if child is 'undefined' it means that we don't need to set this property\n\t    // for example:\n\t    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n\t    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n\t    if (child) parent.tags[tagName] = tags\n\t\n\t    // clone the items array\n\t    oldItems = items.slice()\n\t\n\t  })\n\t\n\t}\n\t/**\n\t * Object that will be used to inject and manage the css of every tag instance\n\t */\n\tvar styleManager = (function(_riot) {\n\t\n\t  if (!window) return { // skip injection on the server\n\t    add: function () {},\n\t    inject: function () {}\n\t  }\n\t\n\t  var styleNode = (function () {\n\t    // create a new style element with the correct type\n\t    var newNode = mkEl('style')\n\t    setAttr(newNode, 'type', 'text/css')\n\t\n\t    // replace any user node or insert the new one into the head\n\t    var userNode = $('style[type=riot]')\n\t    if (userNode) {\n\t      if (userNode.id) newNode.id = userNode.id\n\t      userNode.parentNode.replaceChild(newNode, userNode)\n\t    }\n\t    else document.getElementsByTagName('head')[0].appendChild(newNode)\n\t\n\t    return newNode\n\t  })()\n\t\n\t  // Create cache and shortcut to the correct property\n\t  var cssTextProp = styleNode.styleSheet,\n\t    stylesToInject = ''\n\t\n\t  // Expose the style node in a non-modificable property\n\t  Object.defineProperty(_riot, 'styleNode', {\n\t    value: styleNode,\n\t    writable: true\n\t  })\n\t\n\t  /**\n\t   * Public api\n\t   */\n\t  return {\n\t    /**\n\t     * Save a tag style to be later injected into DOM\n\t     * @param   { String } css [description]\n\t     */\n\t    add: function(css) {\n\t      stylesToInject += css\n\t    },\n\t    /**\n\t     * Inject all previously saved tag styles into DOM\n\t     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n\t     */\n\t    inject: function() {\n\t      if (stylesToInject) {\n\t        if (cssTextProp) cssTextProp.cssText += stylesToInject\n\t        else styleNode.innerHTML += stylesToInject\n\t        stylesToInject = ''\n\t      }\n\t    }\n\t  }\n\t\n\t})(riot)\n\t\n\t\n\tfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\t\n\t  walk(root, function(dom) {\n\t    if (dom.nodeType == 1) {\n\t      dom.isLoop = dom.isLoop ||\n\t                  (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each'))\n\t                    ? 1 : 0\n\t\n\t      // custom child tag\n\t      if (childTags) {\n\t        var child = getTag(dom)\n\t\n\t        if (child && !dom.isLoop)\n\t          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n\t      }\n\t\n\t      if (!dom.isLoop || forceParsingNamed)\n\t        setNamed(dom, tag, [])\n\t    }\n\t\n\t  })\n\t\n\t}\n\t\n\tfunction parseExpressions(root, tag, expressions) {\n\t\n\t  function addExpr(dom, val, extra) {\n\t    if (tmpl.hasExpr(val)) {\n\t      expressions.push(extend({ dom: dom, expr: val }, extra))\n\t    }\n\t  }\n\t\n\t  walk(root, function(dom) {\n\t    var type = dom.nodeType,\n\t      attr\n\t\n\t    // text node\n\t    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n\t    if (type != 1) return\n\t\n\t    /* element */\n\t\n\t    // loop\n\t    attr = getAttr(dom, 'each')\n\t\n\t    if (attr) { _each(dom, tag, attr); return false }\n\t\n\t    // attribute expressions\n\t    each(dom.attributes, function(attr) {\n\t      var name = attr.name,\n\t        bool = name.split('__')[1]\n\t\n\t      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n\t      if (bool) { remAttr(dom, name); return false }\n\t\n\t    })\n\t\n\t    // skip custom tags\n\t    if (getTag(dom)) return false\n\t\n\t  })\n\t\n\t}\n\tfunction Tag(impl, conf, innerHTML) {\n\t\n\t  var self = riot.observable(this),\n\t    opts = inherit(conf.opts) || {},\n\t    parent = conf.parent,\n\t    isLoop = conf.isLoop,\n\t    hasImpl = conf.hasImpl,\n\t    item = cleanUpData(conf.item),\n\t    expressions = [],\n\t    childTags = [],\n\t    root = conf.root,\n\t    tagName = root.tagName.toLowerCase(),\n\t    attr = {},\n\t    propsInSyncWithParent = [],\n\t    dom\n\t\n\t  // only call unmount if we have a valid __tagImpl (has name property)\n\t  if (impl.name && root._tag) root._tag.unmount(true)\n\t\n\t  // not yet mounted\n\t  this.isMounted = false\n\t  root.isLoop = isLoop\n\t\n\t  // keep a reference to the tag just created\n\t  // so we will be able to mount this tag multiple times\n\t  root._tag = this\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\t\n\t  extend(this, { parent: parent, root: root, opts: opts}, item)\n\t  // protect the \"tags\" property from being overridden\n\t  defineProperty(this, 'tags', {})\n\t\n\t  // grab attributes\n\t  each(root.attributes, function(el) {\n\t    var val = el.value\n\t    // remember attributes with expressions only\n\t    if (tmpl.hasExpr(val)) attr[el.name] = val\n\t  })\n\t\n\t  dom = mkdom(impl.tmpl, innerHTML)\n\t\n\t  // options\n\t  function updateOpts() {\n\t    var ctx = hasImpl && isLoop ? self : parent || self\n\t\n\t    // update opts from current DOM attributes\n\t    each(root.attributes, function(el) {\n\t      var val = el.value\n\t      opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val\n\t    })\n\t    // recover those with expressions\n\t    each(Object.keys(attr), function(name) {\n\t      opts[toCamel(name)] = tmpl(attr[name], ctx)\n\t    })\n\t  }\n\t\n\t  function normalizeData(data) {\n\t    for (var key in item) {\n\t      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n\t        self[key] = data[key]\n\t    }\n\t  }\n\t\n\t  function inheritFromParent () {\n\t    if (!self.parent || !isLoop) return\n\t    each(Object.keys(self.parent), function(k) {\n\t      // some properties must be always in sync with the parent tag\n\t      var mustSync = !RESERVED_WORDS_BLACKLIST.test(k) && contains(propsInSyncWithParent, k)\n\t      if (typeof self[k] === T_UNDEF || mustSync) {\n\t        // track the property to keep in sync\n\t        // so we can keep it updated\n\t        if (!mustSync) propsInSyncWithParent.push(k)\n\t        self[k] = self.parent[k]\n\t      }\n\t    })\n\t  }\n\t\n\t  /**\n\t   * Update the tag expressions and options\n\t   * @param   { * }  data - data we want to use to extend the tag properties\n\t   * @param   { Boolean } isInherited - is this update coming from a parent tag?\n\t   * @returns { self }\n\t   */\n\t  defineProperty(this, 'update', function(data, isInherited) {\n\t\n\t    // make sure the data passed will not override\n\t    // the component core methods\n\t    data = cleanUpData(data)\n\t    // inherit properties from the parent\n\t    inheritFromParent()\n\t    // normalize the tag properties in case an item object was initially passed\n\t    if (data && isObject(item)) {\n\t      normalizeData(data)\n\t      item = data\n\t    }\n\t    extend(self, data)\n\t    updateOpts()\n\t    self.trigger('update', data)\n\t    update(expressions, self)\n\t\n\t    // the updated event will be triggered\n\t    // once the DOM will be ready and all the re-flows are completed\n\t    // this is useful if you want to get the \"real\" root properties\n\t    // 4 ex: root.offsetWidth ...\n\t    if (isInherited && self.parent)\n\t      // closes #1599\n\t      self.parent.one('updated', function() { self.trigger('updated') })\n\t    else rAF(function() { self.trigger('updated') })\n\t\n\t    return this\n\t  })\n\t\n\t  defineProperty(this, 'mixin', function() {\n\t    each(arguments, function(mix) {\n\t      var instance\n\t\n\t      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\t\n\t      // check if the mixin is a function\n\t      if (isFunction(mix)) {\n\t        // create the new mixin instance\n\t        instance = new mix()\n\t        // save the prototype to loop it afterwards\n\t        mix = mix.prototype\n\t      } else instance = mix\n\t\n\t      // loop the keys in the function prototype or the all object keys\n\t      each(Object.getOwnPropertyNames(mix), function(key) {\n\t        // bind methods to self\n\t        if (key != 'init')\n\t          self[key] = isFunction(instance[key]) ?\n\t                        instance[key].bind(self) :\n\t                        instance[key]\n\t      })\n\t\n\t      // init method will be called automatically\n\t      if (instance.init) instance.init.bind(self)()\n\t    })\n\t    return this\n\t  })\n\t\n\t  defineProperty(this, 'mount', function() {\n\t\n\t    updateOpts()\n\t\n\t    // add global mixins\n\t    var globalMixin = riot.mixin(GLOBAL_MIXIN)\n\t    if (globalMixin)\n\t      for (var i in globalMixin)\n\t        if (globalMixin.hasOwnProperty(i))\n\t          self.mixin(globalMixin[i])\n\t\n\t    // initialiation\n\t    if (impl.fn) impl.fn.call(self, opts)\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions(dom, self, expressions)\n\t\n\t    // mount the child tags\n\t    toggle(true)\n\t\n\t    // update the root adding custom attributes coming from the compiler\n\t    // it fixes also #1087\n\t    if (impl.attrs)\n\t      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n\t    if (impl.attrs || hasImpl)\n\t      parseExpressions(self.root, self, expressions)\n\t\n\t    if (!self.parent || isLoop) self.update(item)\n\t\n\t    // internal use only, fixes #403\n\t    self.trigger('before-mount')\n\t\n\t    if (isLoop && !hasImpl) {\n\t      // update the root attribute for the looped elements\n\t      root = dom.firstChild\n\t    } else {\n\t      while (dom.firstChild) root.appendChild(dom.firstChild)\n\t      if (root.stub) root = parent.root\n\t    }\n\t\n\t    defineProperty(self, 'root', root)\n\t\n\t    // parse the named dom nodes in the looped child\n\t    // adding them to the parent as well\n\t    if (isLoop)\n\t      parseNamedElements(self.root, self.parent, null, true)\n\t\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!self.parent || self.parent.isMounted) {\n\t      self.isMounted = true\n\t      self.trigger('mount')\n\t    }\n\t    // otherwise we need to wait that the parent event gets triggered\n\t    else self.parent.one('mount', function() {\n\t      // avoid to trigger the `mount` event for the tags\n\t      // not visible included in an if statement\n\t      if (!isInStub(self.root)) {\n\t        self.parent.isMounted = self.isMounted = true\n\t        self.trigger('mount')\n\t      }\n\t    })\n\t  })\n\t\n\t\n\t  defineProperty(this, 'unmount', function(keepRootTag) {\n\t    var el = root,\n\t      p = el.parentNode,\n\t      ptag,\n\t      tagIndex = __virtualDom.indexOf(self)\n\t\n\t    self.trigger('before-unmount')\n\t\n\t    // remove this tag instance from the global virtualDom variable\n\t    if (~tagIndex)\n\t      __virtualDom.splice(tagIndex, 1)\n\t\n\t    if (p) {\n\t\n\t      if (parent) {\n\t        ptag = getImmediateCustomParentTag(parent)\n\t        // remove this tag from the parent tags object\n\t        // if there are multiple nested tags with same name..\n\t        // remove this element form the array\n\t        if (isArray(ptag.tags[tagName]))\n\t          each(ptag.tags[tagName], function(tag, i) {\n\t            if (tag._riot_id == self._riot_id)\n\t              ptag.tags[tagName].splice(i, 1)\n\t          })\n\t        else\n\t          // otherwise just delete the tag instance\n\t          ptag.tags[tagName] = undefined\n\t      }\n\t\n\t      else\n\t        while (el.firstChild) el.removeChild(el.firstChild)\n\t\n\t      if (!keepRootTag)\n\t        p.removeChild(el)\n\t      else {\n\t        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n\t        remAttr(p, RIOT_TAG_IS)\n\t        remAttr(p, RIOT_TAG) // this will be removed in riot 3.0.0\n\t      }\n\t\n\t    }\n\t\n\t    if (this._virts) {\n\t      each(this._virts, function(v) {\n\t        if (v.parentNode) v.parentNode.removeChild(v)\n\t      })\n\t    }\n\t\n\t    self.trigger('unmount')\n\t    toggle()\n\t    self.off('*')\n\t    self.isMounted = false\n\t    delete root._tag\n\t\n\t  })\n\t\n\t  // proxy function to bind updates\n\t  // dispatched from a parent tag\n\t  function onChildUpdate(data) { self.update(data, true) }\n\t\n\t  function toggle(isMount) {\n\t\n\t    // mount/unmount children\n\t    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\t\n\t    // listen/unlisten parent (events flow one way from parent to children)\n\t    if (!parent) return\n\t    var evt = isMount ? 'on' : 'off'\n\t\n\t    // the loop tags will be always in sync with the parent automatically\n\t    if (isLoop)\n\t      parent[evt]('unmount', self.unmount)\n\t    else {\n\t      parent[evt]('update', onChildUpdate)[evt]('unmount', self.unmount)\n\t    }\n\t  }\n\t\n\t\n\t  // named elements available for fn\n\t  parseNamedElements(dom, this, childTags)\n\t\n\t}\n\t/**\n\t * Attach an event to a DOM node\n\t * @param { String } name - event name\n\t * @param { Function } handler - event callback\n\t * @param { Object } dom - dom node\n\t * @param { Tag } tag - tag instance\n\t */\n\tfunction setEventHandler(name, handler, dom, tag) {\n\t\n\t  dom[name] = function(e) {\n\t\n\t    var ptag = tag._parent,\n\t      item = tag._item,\n\t      el\n\t\n\t    if (!item)\n\t      while (ptag && !item) {\n\t        item = ptag._item\n\t        ptag = ptag._parent\n\t      }\n\t\n\t    // cross browser event fix\n\t    e = e || window.event\n\t\n\t    // override the event properties\n\t    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n\t    if (isWritable(e, 'target')) e.target = e.srcElement\n\t    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\t\n\t    e.item = item\n\t\n\t    // prevent default behaviour (by default)\n\t    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n\t      if (e.preventDefault) e.preventDefault()\n\t      e.returnValue = false\n\t    }\n\t\n\t    if (!e.preventUpdate) {\n\t      el = item ? getImmediateCustomParentTag(ptag) : tag\n\t      el.update()\n\t    }\n\t\n\t  }\n\t\n\t}\n\t\n\t\n\t/**\n\t * Insert a DOM node replacing another one (used by if- attribute)\n\t * @param   { Object } root - parent node\n\t * @param   { Object } node - node replaced\n\t * @param   { Object } before - node added\n\t */\n\tfunction insertTo(root, node, before) {\n\t  if (!root) return\n\t  root.insertBefore(before, node)\n\t  root.removeChild(node)\n\t}\n\t\n\t/**\n\t * Update the expressions in a Tag instance\n\t * @param   { Array } expressions - expression that must be re evaluated\n\t * @param   { Tag } tag - tag instance\n\t */\n\tfunction update(expressions, tag) {\n\t\n\t  each(expressions, function(expr, i) {\n\t\n\t    var dom = expr.dom,\n\t      attrName = expr.attr,\n\t      value = tmpl(expr.expr, tag),\n\t      parent = expr.dom.parentNode\n\t\n\t    if (expr.bool) {\n\t      value = !!value\n\t    } else if (value == null) {\n\t      value = ''\n\t    }\n\t\n\t    // #1638: regression of #1612, update the dom only if the value of the\n\t    // expression was changed\n\t    if (expr.value === value) {\n\t      return\n\t    }\n\t    expr.value = value\n\t\n\t    // textarea and text nodes has no attribute name\n\t    if (!attrName) {\n\t      // about #815 w/o replace: the browser converts the value to a string,\n\t      // the comparison by \"==\" does too, but not in the server\n\t      value += ''\n\t      // test for parent avoids error with invalid assignment to nodeValue\n\t      if (parent) {\n\t        if (parent.tagName === 'TEXTAREA') {\n\t          parent.value = value                    // #1113\n\t          if (!IE_VERSION) dom.nodeValue = value  // #1625 IE throws here, nodeValue\n\t        }                                         // will be available on 'updated'\n\t        else dom.nodeValue = value\n\t      }\n\t      return\n\t    }\n\t\n\t    // ~~#1612: look for changes in dom.value when updating the value~~\n\t    if (attrName === 'value') {\n\t      dom.value = value\n\t      return\n\t    }\n\t\n\t    // remove original attribute\n\t    remAttr(dom, attrName)\n\t\n\t    // event handler\n\t    if (isFunction(value)) {\n\t      setEventHandler(attrName, value, dom, tag)\n\t\n\t    // if- conditional\n\t    } else if (attrName == 'if') {\n\t      var stub = expr.stub,\n\t        add = function() { insertTo(stub.parentNode, stub, dom) },\n\t        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\t\n\t      // add to DOM\n\t      if (value) {\n\t        if (stub) {\n\t          add()\n\t          dom.inStub = false\n\t          // avoid to trigger the mount event if the tags is not visible yet\n\t          // maybe we can optimize this avoiding to mount the tag at all\n\t          if (!isInStub(dom)) {\n\t            walk(dom, function(el) {\n\t              if (el._tag && !el._tag.isMounted)\n\t                el._tag.isMounted = !!el._tag.trigger('mount')\n\t            })\n\t          }\n\t        }\n\t      // remove from DOM\n\t      } else {\n\t        stub = expr.stub = stub || document.createTextNode('')\n\t        // if the parentNode is defined we can easily replace the tag\n\t        if (dom.parentNode)\n\t          remove()\n\t        // otherwise we need to wait the updated event\n\t        else (tag.parent || tag).one('updated', remove)\n\t\n\t        dom.inStub = true\n\t      }\n\t    // show / hide\n\t    } else if (attrName === 'show') {\n\t      dom.style.display = value ? '' : 'none'\n\t\n\t    } else if (attrName === 'hide') {\n\t      dom.style.display = value ? 'none' : ''\n\t\n\t    } else if (expr.bool) {\n\t      dom[attrName] = value\n\t      if (value) setAttr(dom, attrName, attrName)\n\t      if (FIREFOX && attrName === 'selected' && dom.tagName === 'OPTION') {\n\t        dom.__riot1374 = value   // #1374\n\t      }\n\t\n\t    } else if (value === 0 || value && typeof value !== T_OBJECT) {\n\t      // <img src=\"{ expr }\">\n\t      if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n\t        attrName = attrName.slice(RIOT_PREFIX.length)\n\t      }\n\t      setAttr(dom, attrName, value)\n\t    }\n\t\n\t  })\n\t\n\t}\n\t/**\n\t * Specialized function for looping an array-like collection with `each={}`\n\t * @param   { Array } els - collection of items\n\t * @param   {Function} fn - callback function\n\t * @returns { Array } the array looped\n\t */\n\tfunction each(els, fn) {\n\t  var len = els ? els.length : 0\n\t\n\t  for (var i = 0, el; i < len; i++) {\n\t    el = els[i]\n\t    // return false -> current item was removed by fn during the loop\n\t    if (el != null && fn(el, i) === false) i--\n\t  }\n\t  return els\n\t}\n\t\n\t/**\n\t * Detect if the argument passed is a function\n\t * @param   { * } v - whatever you want to pass to this function\n\t * @returns { Boolean } -\n\t */\n\tfunction isFunction(v) {\n\t  return typeof v === T_FUNCTION || false   // avoid IE problems\n\t}\n\t\n\t/**\n\t * Get the outer html of any DOM node SVGs included\n\t * @param   { Object } el - DOM node to parse\n\t * @returns { String } el.outerHTML\n\t */\n\tfunction getOuterHTML(el) {\n\t  if (el.outerHTML) return el.outerHTML\n\t  // some browsers do not support outerHTML on the SVGs tags\n\t  else {\n\t    var container = mkEl('div')\n\t    container.appendChild(el.cloneNode(true))\n\t    return container.innerHTML\n\t  }\n\t}\n\t\n\t/**\n\t * Set the inner html of any DOM node SVGs included\n\t * @param { Object } container - DOM node where we will inject the new html\n\t * @param { String } html - html to inject\n\t */\n\tfunction setInnerHTML(container, html) {\n\t  if (typeof container.innerHTML != T_UNDEF) container.innerHTML = html\n\t  // some browsers do not support innerHTML on the SVGs tags\n\t  else {\n\t    var doc = new DOMParser().parseFromString(html, 'application/xml')\n\t    container.appendChild(\n\t      container.ownerDocument.importNode(doc.documentElement, true)\n\t    )\n\t  }\n\t}\n\t\n\t/**\n\t * Checks wether a DOM node must be considered part of an svg document\n\t * @param   { String }  name - tag name\n\t * @returns { Boolean } -\n\t */\n\tfunction isSVGTag(name) {\n\t  return ~SVG_TAGS_LIST.indexOf(name)\n\t}\n\t\n\t/**\n\t * Detect if the argument passed is an object, exclude null.\n\t * NOTE: Use isObject(x) && !isArray(x) to excludes arrays.\n\t * @param   { * } v - whatever you want to pass to this function\n\t * @returns { Boolean } -\n\t */\n\tfunction isObject(v) {\n\t  return v && typeof v === T_OBJECT         // typeof null is 'object'\n\t}\n\t\n\t/**\n\t * Remove any DOM attribute from a node\n\t * @param   { Object } dom - DOM node we want to update\n\t * @param   { String } name - name of the property we want to remove\n\t */\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name)\n\t}\n\t\n\t/**\n\t * Convert a string containing dashes to camel case\n\t * @param   { String } string - input string\n\t * @returns { String } my-string -> myString\n\t */\n\tfunction toCamel(string) {\n\t  return string.replace(/-(\\w)/g, function(_, c) {\n\t    return c.toUpperCase()\n\t  })\n\t}\n\t\n\t/**\n\t * Get the value of any DOM attribute on a node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { String } name - name of the attribute we want to get\n\t * @returns { String | undefined } name of the node attribute whether it exists\n\t */\n\tfunction getAttr(dom, name) {\n\t  return dom.getAttribute(name)\n\t}\n\t\n\t/**\n\t * Set any DOM attribute\n\t * @param { Object } dom - DOM node we want to update\n\t * @param { String } name - name of the property we want to set\n\t * @param { String } val - value of the property we want to set\n\t */\n\tfunction setAttr(dom, name, val) {\n\t  dom.setAttribute(name, val)\n\t}\n\t\n\t/**\n\t * Detect the tag implementation by a DOM node\n\t * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n\t * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n\t */\n\tfunction getTag(dom) {\n\t  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG_IS) ||\n\t    getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n\t}\n\t/**\n\t * Add a child tag to its parent into the `tags` object\n\t * @param   { Object } tag - child tag instance\n\t * @param   { String } tagName - key where the new tag will be stored\n\t * @param   { Object } parent - tag instance where the new child tag will be included\n\t */\n\tfunction addChildTag(tag, tagName, parent) {\n\t  var cachedTag = parent.tags[tagName]\n\t\n\t  // if there are multiple children tags having the same name\n\t  if (cachedTag) {\n\t    // if the parent tags property is not yet an array\n\t    // create it adding the first cached tag\n\t    if (!isArray(cachedTag))\n\t      // don't add the same tag twice\n\t      if (cachedTag !== tag)\n\t        parent.tags[tagName] = [cachedTag]\n\t    // add the new nested tag to the array\n\t    if (!contains(parent.tags[tagName], tag))\n\t      parent.tags[tagName].push(tag)\n\t  } else {\n\t    parent.tags[tagName] = tag\n\t  }\n\t}\n\t\n\t/**\n\t * Move the position of a custom tag in its parent tag\n\t * @param   { Object } tag - child tag instance\n\t * @param   { String } tagName - key where the tag was stored\n\t * @param   { Number } newPos - index where the new tag will be stored\n\t */\n\tfunction moveChildTag(tag, tagName, newPos) {\n\t  var parent = tag.parent,\n\t    tags\n\t  // no parent no move\n\t  if (!parent) return\n\t\n\t  tags = parent.tags[tagName]\n\t\n\t  if (isArray(tags))\n\t    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n\t  else addChildTag(tag, tagName, parent)\n\t}\n\t\n\t/**\n\t * Create a new child tag including it correctly into its parent\n\t * @param   { Object } child - child tag implementation\n\t * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n\t * @param   { String } innerHTML - inner html of the child node\n\t * @param   { Object } parent - instance of the parent tag including the child custom tag\n\t * @returns { Object } instance of the new child tag just created\n\t */\n\tfunction initChildTag(child, opts, innerHTML, parent) {\n\t  var tag = new Tag(child, opts, innerHTML),\n\t    tagName = getTagName(opts.root),\n\t    ptag = getImmediateCustomParentTag(parent)\n\t  // fix for the parent attribute in the looped elements\n\t  tag.parent = ptag\n\t  // store the real parent tag\n\t  // in some cases this could be different from the custom parent tag\n\t  // for example in nested loops\n\t  tag._parent = parent\n\t\n\t  // add this tag to the custom parent tag\n\t  addChildTag(tag, tagName, ptag)\n\t  // and also to the real parent tag\n\t  if (ptag !== parent)\n\t    addChildTag(tag, tagName, parent)\n\t  // empty the child node once we got its template\n\t  // to avoid that its children get compiled multiple times\n\t  opts.root.innerHTML = ''\n\t\n\t  return tag\n\t}\n\t\n\t/**\n\t * Loop backward all the parents tree to detect the first custom parent tag\n\t * @param   { Object } tag - a Tag instance\n\t * @returns { Object } the instance of the first custom parent tag found\n\t */\n\tfunction getImmediateCustomParentTag(tag) {\n\t  var ptag = tag\n\t  while (!getTag(ptag.root)) {\n\t    if (!ptag.parent) break\n\t    ptag = ptag.parent\n\t  }\n\t  return ptag\n\t}\n\t\n\t/**\n\t * Helper function to set an immutable property\n\t * @param   { Object } el - object where the new property will be set\n\t * @param   { String } key - object key where the new property will be stored\n\t * @param   { * } value - value of the new property\n\t* @param   { Object } options - set the propery overriding the default options\n\t * @returns { Object } - the initial object\n\t */\n\tfunction defineProperty(el, key, value, options) {\n\t  Object.defineProperty(el, key, extend({\n\t    value: value,\n\t    enumerable: false,\n\t    writable: false,\n\t    configurable: true\n\t  }, options))\n\t  return el\n\t}\n\t\n\t/**\n\t * Get the tag name of any DOM node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @returns { String } name to identify this dom node in riot\n\t */\n\tfunction getTagName(dom) {\n\t  var child = getTag(dom),\n\t    namedTag = getAttr(dom, 'name'),\n\t    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n\t                namedTag :\n\t              child ? child.name : dom.tagName.toLowerCase()\n\t\n\t  return tagName\n\t}\n\t\n\t/**\n\t * Extend any object with other properties\n\t * @param   { Object } src - source object\n\t * @returns { Object } the resulting extended object\n\t *\n\t * var obj = { foo: 'baz' }\n\t * extend(obj, {bar: 'bar', foo: 'bar'})\n\t * console.log(obj) => {bar: 'bar', foo: 'bar'}\n\t *\n\t */\n\tfunction extend(src) {\n\t  var obj, args = arguments\n\t  for (var i = 1; i < args.length; ++i) {\n\t    if (obj = args[i]) {\n\t      for (var key in obj) {\n\t        // check if this property of the source object could be overridden\n\t        if (isWritable(src, key))\n\t          src[key] = obj[key]\n\t      }\n\t    }\n\t  }\n\t  return src\n\t}\n\t\n\t/**\n\t * Check whether an array contains an item\n\t * @param   { Array } arr - target array\n\t * @param   { * } item - item to test\n\t * @returns { Boolean } Does 'arr' contain 'item'?\n\t */\n\tfunction contains(arr, item) {\n\t  return ~arr.indexOf(item)\n\t}\n\t\n\t/**\n\t * Check whether an object is a kind of array\n\t * @param   { * } a - anything\n\t * @returns {Boolean} is 'a' an array?\n\t */\n\tfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\t\n\t/**\n\t * Detect whether a property of an object could be overridden\n\t * @param   { Object }  obj - source object\n\t * @param   { String }  key - object property\n\t * @returns { Boolean } is this property writable?\n\t */\n\tfunction isWritable(obj, key) {\n\t  var props = Object.getOwnPropertyDescriptor(obj, key)\n\t  return typeof obj[key] === T_UNDEF || props && props.writable\n\t}\n\t\n\t\n\t/**\n\t * With this function we avoid that the internal Tag methods get overridden\n\t * @param   { Object } data - options we want to use to extend the tag instance\n\t * @returns { Object } clean object without containing the riot internal reserved words\n\t */\n\tfunction cleanUpData(data) {\n\t  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))\n\t    return data\n\t\n\t  var o = {}\n\t  for (var key in data) {\n\t    if (!RESERVED_WORDS_BLACKLIST.test(key)) o[key] = data[key]\n\t  }\n\t  return o\n\t}\n\t\n\t/**\n\t * Walk down recursively all the children tags starting dom node\n\t * @param   { Object }   dom - starting node where we will start the recursion\n\t * @param   { Function } fn - callback to transform the child node just found\n\t */\n\tfunction walk(dom, fn) {\n\t  if (dom) {\n\t    // stop the recursion\n\t    if (fn(dom) === false) return\n\t    else {\n\t      dom = dom.firstChild\n\t\n\t      while (dom) {\n\t        walk(dom, fn)\n\t        dom = dom.nextSibling\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Minimize risk: only zero or one _space_ between attr & value\n\t * @param   { String }   html - html string we want to parse\n\t * @param   { Function } fn - callback function to apply on any attribute found\n\t */\n\tfunction walkAttributes(html, fn) {\n\t  var m,\n\t    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\t\n\t  while (m = re.exec(html)) {\n\t    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n\t  }\n\t}\n\t\n\t/**\n\t * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n\t * @param   { Object }  dom - DOM node we want to parse\n\t * @returns { Boolean } -\n\t */\n\tfunction isInStub(dom) {\n\t  while (dom) {\n\t    if (dom.inStub) return true\n\t    dom = dom.parentNode\n\t  }\n\t  return false\n\t}\n\t\n\t/**\n\t * Create a generic DOM node\n\t * @param   { String } name - name of the DOM node we want to create\n\t * @param   { Boolean } isSvg - should we use a SVG as parent node?\n\t * @returns { Object } DOM node just created\n\t */\n\tfunction mkEl(name, isSvg) {\n\t  return isSvg ?\n\t    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n\t    document.createElement(name)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select multiple nodes in the DOM\n\t * @param   { String } selector - DOM selector\n\t * @param   { Object } ctx - DOM node where the targets of our search will is located\n\t * @returns { Object } dom nodes found\n\t */\n\tfunction $$(selector, ctx) {\n\t  return (ctx || document).querySelectorAll(selector)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select a single node in the DOM\n\t * @param   { String } selector - unique dom selector\n\t * @param   { Object } ctx - DOM node where the target of our search will is located\n\t * @returns { Object } dom node found\n\t */\n\tfunction $(selector, ctx) {\n\t  return (ctx || document).querySelector(selector)\n\t}\n\t\n\t/**\n\t * Simple object prototypal inheritance\n\t * @param   { Object } parent - parent object\n\t * @returns { Object } child instance\n\t */\n\tfunction inherit(parent) {\n\t  function Child() {}\n\t  Child.prototype = parent\n\t  return new Child()\n\t}\n\t\n\t/**\n\t * Get the name property needed to identify a DOM node in riot\n\t * @param   { Object } dom - DOM node we need to parse\n\t * @returns { String | undefined } give us back a string to identify this dom node\n\t */\n\tfunction getNamedKey(dom) {\n\t  return getAttr(dom, 'id') || getAttr(dom, 'name')\n\t}\n\t\n\t/**\n\t * Set the named properties of a tag element\n\t * @param { Object } dom - DOM node we need to parse\n\t * @param { Object } parent - tag instance where the named dom element will be eventually added\n\t * @param { Array } keys - list of all the tag instance properties\n\t */\n\tfunction setNamed(dom, parent, keys) {\n\t  // get the key value we want to add to the tag instance\n\t  var key = getNamedKey(dom),\n\t    isArr,\n\t    // add the node detected to a tag instance using the named property\n\t    add = function(value) {\n\t      // avoid to override the tag properties already set\n\t      if (contains(keys, key)) return\n\t      // check whether this value is an array\n\t      isArr = isArray(value)\n\t      // if the key was never set\n\t      if (!value)\n\t        // set it once on the tag instance\n\t        parent[key] = dom\n\t      // if it was an array and not yet set\n\t      else if (!isArr || isArr && !contains(value, dom)) {\n\t        // add the dom node into the array\n\t        if (isArr)\n\t          value.push(dom)\n\t        else\n\t          parent[key] = [value, dom]\n\t      }\n\t    }\n\t\n\t  // skip the elements with no named properties\n\t  if (!key) return\n\t\n\t  // check whether this key has been already evaluated\n\t  if (tmpl.hasExpr(key))\n\t    // wait the first updated event only once\n\t    parent.one('mount', function() {\n\t      key = getNamedKey(dom)\n\t      add(parent[key])\n\t    })\n\t  else\n\t    add(parent[key])\n\t\n\t}\n\t\n\t/**\n\t * Faster String startsWith alternative\n\t * @param   { String } src - source string\n\t * @param   { String } str - test string\n\t * @returns { Boolean } -\n\t */\n\tfunction startsWith(src, str) {\n\t  return src.slice(0, str.length) === str\n\t}\n\t\n\t/**\n\t * requestAnimationFrame function\n\t * Adapted from https://gist.github.com/paulirish/1579671, license MIT\n\t */\n\tvar rAF = (function (w) {\n\t  var raf = w.requestAnimationFrame    ||\n\t            w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame\n\t\n\t  if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {  // buggy iOS6\n\t    var lastTime = 0\n\t\n\t    raf = function (cb) {\n\t      var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0)\n\t      setTimeout(function () { cb(lastTime = nowtime + timeout) }, timeout)\n\t    }\n\t  }\n\t  return raf\n\t\n\t})(window || {})\n\t\n\t/**\n\t * Mount a tag creating new Tag instance\n\t * @param   { Object } root - dom node where the tag will be mounted\n\t * @param   { String } tagName - name of the riot tag we want to mount\n\t * @param   { Object } opts - options to pass to the Tag instance\n\t * @returns { Tag } a new Tag instance\n\t */\n\tfunction mountTo(root, tagName, opts) {\n\t  var tag = __tagImpl[tagName],\n\t    // cache the inner HTML to fix #855\n\t    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\t\n\t  // clear the inner html\n\t  root.innerHTML = ''\n\t\n\t  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount()\n\t    // add this tag to the virtualDom variable\n\t    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n\t  }\n\t\n\t  return tag\n\t}\n\t/**\n\t * Riot public api\n\t */\n\t\n\t// share methods for other riot parts, e.g. compiler\n\triot.util = { brackets: brackets, tmpl: tmpl }\n\t\n\t/**\n\t * Create a mixin that could be globally shared across all the tags\n\t */\n\triot.mixin = (function() {\n\t  var mixins = {},\n\t    globals = mixins[GLOBAL_MIXIN] = {},\n\t    _id = 0\n\t\n\t  /**\n\t   * Create/Return a mixin by its name\n\t   * @param   { String }  name - mixin name (global mixin if object)\n\t   * @param   { Object }  mixin - mixin logic\n\t   * @param   { Boolean } g - is global?\n\t   * @returns { Object }  the mixin logic\n\t   */\n\t  return function(name, mixin, g) {\n\t    // Unnamed global\n\t    if (isObject(name)) {\n\t      riot.mixin('__unnamed_'+_id++, name, true)\n\t      return\n\t    }\n\t\n\t    var store = g ? globals : mixins\n\t\n\t    // Getter\n\t    if (!mixin) {\n\t      if (typeof store[name] === T_UNDEF) {\n\t        throw new Error('Unregistered mixin: ' + name)\n\t      }\n\t      return store[name]\n\t    }\n\t    // Setter\n\t    if (isFunction(mixin)) {\n\t      extend(mixin.prototype, store[name] || {})\n\t      store[name] = mixin\n\t    }\n\t    else {\n\t      store[name] = extend(store[name] || {}, mixin)\n\t    }\n\t  }\n\t\n\t})()\n\t\n\t/**\n\t * Create a new riot tag implementation\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   html - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\triot.tag = function(name, html, css, attrs, fn) {\n\t  if (isFunction(attrs)) {\n\t    fn = attrs\n\t    if (/^[\\w\\-]+\\s?=/.test(css)) {\n\t      attrs = css\n\t      css = ''\n\t    } else attrs = ''\n\t  }\n\t  if (css) {\n\t    if (isFunction(css)) fn = css\n\t    else styleManager.add(css)\n\t  }\n\t  name = name.toLowerCase()\n\t  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n\t  return name\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation (for use by the compiler)\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   html - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\triot.tag2 = function(name, html, css, attrs, fn) {\n\t  if (css) styleManager.add(css)\n\t  //if (bpair) riot.settings.brackets = bpair\n\t  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n\t  return name\n\t}\n\t\n\t/**\n\t * Mount a tag using a specific tag implementation\n\t * @param   { String } selector - tag DOM selector\n\t * @param   { String } tagName - tag implementation name\n\t * @param   { Object } opts - tag logic\n\t * @returns { Array } new tags instances\n\t */\n\triot.mount = function(selector, tagName, opts) {\n\t\n\t  var els,\n\t    allTags,\n\t    tags = []\n\t\n\t  // helper functions\n\t\n\t  function addRiotTags(arr) {\n\t    var list = ''\n\t    each(arr, function (e) {\n\t      if (!/[^-\\w]/.test(e)) {\n\t        e = e.trim().toLowerCase()\n\t        list += ',[' + RIOT_TAG_IS + '=\"' + e + '\"],[' + RIOT_TAG + '=\"' + e + '\"]'\n\t      }\n\t    })\n\t    return list\n\t  }\n\t\n\t  function selectAllTags() {\n\t    var keys = Object.keys(__tagImpl)\n\t    return keys + addRiotTags(keys)\n\t  }\n\t\n\t  function pushTags(root) {\n\t    if (root.tagName) {\n\t      var riotTag = getAttr(root, RIOT_TAG_IS) || getAttr(root, RIOT_TAG)\n\t\n\t      // have tagName? force riot-tag to be the same\n\t      if (tagName && riotTag !== tagName) {\n\t        riotTag = tagName\n\t        setAttr(root, RIOT_TAG_IS, tagName)\n\t        setAttr(root, RIOT_TAG, tagName) // this will be removed in riot 3.0.0\n\t      }\n\t      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)\n\t\n\t      if (tag) tags.push(tag)\n\t    } else if (root.length) {\n\t      each(root, pushTags)   // assume nodeList\n\t    }\n\t  }\n\t\n\t  // ----- mount code -----\n\t\n\t  // inject styles into DOM\n\t  styleManager.inject()\n\t\n\t  if (isObject(tagName)) {\n\t    opts = tagName\n\t    tagName = 0\n\t  }\n\t\n\t  // crawl the DOM to find the tag\n\t  if (typeof selector === T_STRING) {\n\t    if (selector === '*')\n\t      // select all the tags registered\n\t      // and also the tags found with the riot-tag attribute set\n\t      selector = allTags = selectAllTags()\n\t    else\n\t      // or just the ones named like the selector\n\t      selector += addRiotTags(selector.split(/, */))\n\t\n\t    // make sure to pass always a selector\n\t    // to the querySelectorAll function\n\t    els = selector ? $$(selector) : []\n\t  }\n\t  else\n\t    // probably you have passed already a tag or a NodeList\n\t    els = selector\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName === '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selectAllTags()\n\t    // if the root els it's just a single tag\n\t    if (els.tagName)\n\t      els = $$(tagName, els)\n\t    else {\n\t      // select all the children for all the different root elements\n\t      var nodeList = []\n\t      each(els, function (_el) {\n\t        nodeList.push($$(tagName, _el))\n\t      })\n\t      els = nodeList\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0\n\t  }\n\t\n\t  pushTags(els)\n\t\n\t  return tags\n\t}\n\t\n\t/**\n\t * Update all the tags instances created\n\t * @returns { Array } all the tags instances\n\t */\n\triot.update = function() {\n\t  return each(__virtualDom, function(tag) {\n\t    tag.update()\n\t  })\n\t}\n\t\n\t/**\n\t * Export the Virtual DOM\n\t */\n\triot.vdom = __virtualDom\n\t\n\t/**\n\t * Export the Tag constructor\n\t */\n\triot.Tag = Tag\n\t  // support CommonJS, AMD & browser\n\t  /* istanbul ignore next */\n\t  if (typeof exports === T_OBJECT)\n\t    module.exports = riot\n\t  else if (\"function\" === T_FUNCTION && typeof __webpack_require__(29) !== T_UNDEF)\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return riot }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\t  else\n\t    window.riot = riot\n\t\n\t})(typeof window != 'undefined' ? window : void 0);\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getPrototype = __webpack_require__(19),\n\t    isHostObject = __webpack_require__(20),\n\t    isObjectLike = __webpack_require__(21);\n\t\n\t/** `Object#toString` result references. */\n\tvar objectTag = '[object Object]';\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to resolve the decompiled source of functions. */\n\tvar funcToString = Function.prototype.toString;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/** Used to infer the `Object` constructor. */\n\tvar objectCtorString = funcToString.call(Object);\n\t\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objectToString = objectProto.toString;\n\t\n\t/**\n\t * Checks if `value` is a plain object, that is, an object created by the\n\t * `Object` constructor or one with a `[[Prototype]]` of `null`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.8.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a plain object,\n\t *  else `false`.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t * }\n\t *\n\t * _.isPlainObject(new Foo);\n\t * // => false\n\t *\n\t * _.isPlainObject([1, 2, 3]);\n\t * // => false\n\t *\n\t * _.isPlainObject({ 'x': 0, 'y': 0 });\n\t * // => true\n\t *\n\t * _.isPlainObject(Object.create(null));\n\t * // => true\n\t */\n\tfunction isPlainObject(value) {\n\t  if (!isObjectLike(value) ||\n\t      objectToString.call(value) != objectTag || isHostObject(value)) {\n\t    return false;\n\t  }\n\t  var proto = getPrototype(value);\n\t  if (proto === null) {\n\t    return true;\n\t  }\n\t  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n\t  return (typeof Ctor == 'function' &&\n\t    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n\t}\n\t\n\tmodule.exports = isPlainObject;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = compose;\n\t/**\n\t * Composes single-argument functions from right to left. The rightmost\n\t * function can take multiple arguments as it provides the signature for\n\t * the resulting composite function.\n\t *\n\t * @param {...Function} funcs The functions to compose.\n\t * @returns {Function} A function obtained by composing the argument functions\n\t * from right to left. For example, compose(f, g, h) is identical to doing\n\t * (...args) => f(g(h(...args))).\n\t */\n\t\n\tfunction compose() {\n\t  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n\t    funcs[_key] = arguments[_key];\n\t  }\n\t\n\t  if (funcs.length === 0) {\n\t    return function (arg) {\n\t      return arg;\n\t    };\n\t  } else {\n\t    var _ret = function () {\n\t      var last = funcs[funcs.length - 1];\n\t      var rest = funcs.slice(0, -1);\n\t      return {\n\t        v: function v() {\n\t          return rest.reduceRight(function (composed, f) {\n\t            return f(composed);\n\t          }, last.apply(undefined, arguments));\n\t        }\n\t      };\n\t    }();\n\t\n\t    if (typeof _ret === \"object\") return _ret.v;\n\t  }\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.ActionTypes = undefined;\n\texports[\"default\"] = createStore;\n\t\n\tvar _isPlainObject = __webpack_require__(2);\n\t\n\tvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\t\n\tvar _symbolObservable = __webpack_require__(27);\n\t\n\tvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\t/**\n\t * These are private action types reserved by Redux.\n\t * For any unknown actions, you must return the current state.\n\t * If the current state is undefined, you must return the initial state.\n\t * Do not reference these action types directly in your code.\n\t */\n\tvar ActionTypes = exports.ActionTypes = {\n\t  INIT: '@@redux/INIT'\n\t};\n\t\n\t/**\n\t * Creates a Redux store that holds the state tree.\n\t * The only way to change the data in the store is to call `dispatch()` on it.\n\t *\n\t * There should only be a single store in your app. To specify how different\n\t * parts of the state tree respond to actions, you may combine several reducers\n\t * into a single reducer function by using `combineReducers`.\n\t *\n\t * @param {Function} reducer A function that returns the next state tree, given\n\t * the current state tree and the action to handle.\n\t *\n\t * @param {any} [initialState] The initial state. You may optionally specify it\n\t * to hydrate the state from the server in universal apps, or to restore a\n\t * previously serialized user session.\n\t * If you use `combineReducers` to produce the root reducer function, this must be\n\t * an object with the same shape as `combineReducers` keys.\n\t *\n\t * @param {Function} enhancer The store enhancer. You may optionally specify it\n\t * to enhance the store with third-party capabilities such as middleware,\n\t * time travel, persistence, etc. The only store enhancer that ships with Redux\n\t * is `applyMiddleware()`.\n\t *\n\t * @returns {Store} A Redux store that lets you read the state, dispatch actions\n\t * and subscribe to changes.\n\t */\n\tfunction createStore(reducer, initialState, enhancer) {\n\t  var _ref2;\n\t\n\t  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {\n\t    enhancer = initialState;\n\t    initialState = undefined;\n\t  }\n\t\n\t  if (typeof enhancer !== 'undefined') {\n\t    if (typeof enhancer !== 'function') {\n\t      throw new Error('Expected the enhancer to be a function.');\n\t    }\n\t\n\t    return enhancer(createStore)(reducer, initialState);\n\t  }\n\t\n\t  if (typeof reducer !== 'function') {\n\t    throw new Error('Expected the reducer to be a function.');\n\t  }\n\t\n\t  var currentReducer = reducer;\n\t  var currentState = initialState;\n\t  var currentListeners = [];\n\t  var nextListeners = currentListeners;\n\t  var isDispatching = false;\n\t\n\t  function ensureCanMutateNextListeners() {\n\t    if (nextListeners === currentListeners) {\n\t      nextListeners = currentListeners.slice();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Reads the state tree managed by the store.\n\t   *\n\t   * @returns {any} The current state tree of your application.\n\t   */\n\t  function getState() {\n\t    return currentState;\n\t  }\n\t\n\t  /**\n\t   * Adds a change listener. It will be called any time an action is dispatched,\n\t   * and some part of the state tree may potentially have changed. You may then\n\t   * call `getState()` to read the current state tree inside the callback.\n\t   *\n\t   * You may call `dispatch()` from a change listener, with the following\n\t   * caveats:\n\t   *\n\t   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n\t   * If you subscribe or unsubscribe while the listeners are being invoked, this\n\t   * will not have any effect on the `dispatch()` that is currently in progress.\n\t   * However, the next `dispatch()` call, whether nested or not, will use a more\n\t   * recent snapshot of the subscription list.\n\t   *\n\t   * 2. The listener should not expect to see all state changes, as the state\n\t   * might have been updated multiple times during a nested `dispatch()` before\n\t   * the listener is called. It is, however, guaranteed that all subscribers\n\t   * registered before the `dispatch()` started will be called with the latest\n\t   * state by the time it exits.\n\t   *\n\t   * @param {Function} listener A callback to be invoked on every dispatch.\n\t   * @returns {Function} A function to remove this change listener.\n\t   */\n\t  function subscribe(listener) {\n\t    if (typeof listener !== 'function') {\n\t      throw new Error('Expected listener to be a function.');\n\t    }\n\t\n\t    var isSubscribed = true;\n\t\n\t    ensureCanMutateNextListeners();\n\t    nextListeners.push(listener);\n\t\n\t    return function unsubscribe() {\n\t      if (!isSubscribed) {\n\t        return;\n\t      }\n\t\n\t      isSubscribed = false;\n\t\n\t      ensureCanMutateNextListeners();\n\t      var index = nextListeners.indexOf(listener);\n\t      nextListeners.splice(index, 1);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Dispatches an action. It is the only way to trigger a state change.\n\t   *\n\t   * The `reducer` function, used to create the store, will be called with the\n\t   * current state tree and the given `action`. Its return value will\n\t   * be considered the **next** state of the tree, and the change listeners\n\t   * will be notified.\n\t   *\n\t   * The base implementation only supports plain object actions. If you want to\n\t   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n\t   * wrap your store creating function into the corresponding middleware. For\n\t   * example, see the documentation for the `redux-thunk` package. Even the\n\t   * middleware will eventually dispatch plain object actions using this method.\n\t   *\n\t   * @param {Object} action A plain object representing what changed. It is\n\t   * a good idea to keep actions serializable so you can record and replay user\n\t   * sessions, or use the time travelling `redux-devtools`. An action must have\n\t   * a `type` property which may not be `undefined`. It is a good idea to use\n\t   * string constants for action types.\n\t   *\n\t   * @returns {Object} For convenience, the same action object you dispatched.\n\t   *\n\t   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n\t   * return something else (for example, a Promise you can await).\n\t   */\n\t  function dispatch(action) {\n\t    if (!(0, _isPlainObject2[\"default\"])(action)) {\n\t      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n\t    }\n\t\n\t    if (typeof action.type === 'undefined') {\n\t      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n\t    }\n\t\n\t    if (isDispatching) {\n\t      throw new Error('Reducers may not dispatch actions.');\n\t    }\n\t\n\t    try {\n\t      isDispatching = true;\n\t      currentState = currentReducer(currentState, action);\n\t    } finally {\n\t      isDispatching = false;\n\t    }\n\t\n\t    var listeners = currentListeners = nextListeners;\n\t    for (var i = 0; i < listeners.length; i++) {\n\t      listeners[i]();\n\t    }\n\t\n\t    return action;\n\t  }\n\t\n\t  /**\n\t   * Replaces the reducer currently used by the store to calculate the state.\n\t   *\n\t   * You might need this if your app implements code splitting and you want to\n\t   * load some of the reducers dynamically. You might also need this if you\n\t   * implement a hot reloading mechanism for Redux.\n\t   *\n\t   * @param {Function} nextReducer The reducer for the store to use instead.\n\t   * @returns {void}\n\t   */\n\t  function replaceReducer(nextReducer) {\n\t    if (typeof nextReducer !== 'function') {\n\t      throw new Error('Expected the nextReducer to be a function.');\n\t    }\n\t\n\t    currentReducer = nextReducer;\n\t    dispatch({ type: ActionTypes.INIT });\n\t  }\n\t\n\t  /**\n\t   * Interoperability point for observable/reactive libraries.\n\t   * @returns {observable} A minimal observable of state changes.\n\t   * For more information, see the observable proposal:\n\t   * https://github.com/zenparsing/es-observable\n\t   */\n\t  function observable() {\n\t    var _ref;\n\t\n\t    var outerSubscribe = subscribe;\n\t    return _ref = {\n\t      /**\n\t       * The minimal observable subscription method.\n\t       * @param {Object} observer Any object that can be used as an observer.\n\t       * The observer object should have a `next` method.\n\t       * @returns {subscription} An object with an `unsubscribe` method that can\n\t       * be used to unsubscribe the observable from the store, and prevent further\n\t       * emission of values from the observable.\n\t       */\n\t\n\t      subscribe: function subscribe(observer) {\n\t        if (typeof observer !== 'object') {\n\t          throw new TypeError('Expected the observer to be an object.');\n\t        }\n\t\n\t        function observeState() {\n\t          if (observer.next) {\n\t            observer.next(getState());\n\t          }\n\t        }\n\t\n\t        observeState();\n\t        var unsubscribe = outerSubscribe(observeState);\n\t        return { unsubscribe: unsubscribe };\n\t      }\n\t    }, _ref[_symbolObservable2[\"default\"]] = function () {\n\t      return this;\n\t    }, _ref;\n\t  }\n\t\n\t  // When a store is created, an \"INIT\" action is dispatched so that every\n\t  // reducer returns their initial state. This effectively populates\n\t  // the initial state tree.\n\t  dispatch({ type: ActionTypes.INIT });\n\t\n\t  return _ref2 = {\n\t    dispatch: dispatch,\n\t    subscribe: subscribe,\n\t    getState: getState,\n\t    replaceReducer: replaceReducer\n\t  }, _ref2[_symbolObservable2[\"default\"]] = observable, _ref2;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = warning;\n\t/**\n\t * Prints a warning in the console if it exists.\n\t *\n\t * @param {String} message The warning message.\n\t * @returns {void}\n\t */\n\tfunction warning(message) {\n\t  /* eslint-disable no-console */\n\t  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n\t    console.error(message);\n\t  }\n\t  /* eslint-enable no-console */\n\t  try {\n\t    // This error was thrown as a convenience so that if you enable\n\t    // \"break on all exceptions\" in your console,\n\t    // it would pause the execution at this line.\n\t    throw new Error(message);\n\t    /* eslint-disable no-empty */\n\t  } catch (e) {}\n\t  /* eslint-enable no-empty */\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar riot = __webpack_require__(1);\n\t\n\triot.tag2('app', '<header category=\"{state.category}\"></header> <div class=\"wrapper\" onclick=\"{close}\"> <section class=\"{focus: selected}\"> <h3 if=\"{!state.items.hasError && !state.items.isFetching}\">{state.title}</h3> <h3 class=\"message-status\" if=\"{state.items.hasError}\">Sorry, something went wrong.</h3> <h3 class=\"message-status\" if=\"{state.items.isFetching}\"><p class=\"loading\"><span>.</span><span>.</span><span>.</span></p></h3> <ul> <li each=\"{this.state.items.data}\" no-reorder> <item data=\"{this}\"></item> </li> </ul> </section> </div> <footer></footer>', '', '', function (opts) {\n\t  var _this = this;\n\t\n\t  var store = opts.store;\n\t\n\t  this.state = store.getState();\n\t\n\t  store.subscribe(function () {\n\t    _this.state = store.getState();\n\t    _this.update();\n\t  });\n\t\n\t  this.fetchCategory = function (category) {\n\t    store.dispatch({ type: 'FETCH_INIT' });\n\t    fetch(SERVICE_URL + '/feed/' + category).then(function (response) {\n\t      return response.json();\n\t    }).then(function (data) {\n\t      return store.dispatch({ type: 'FETCH_SUCCESS', data: data });\n\t    }).catch(function (e) {\n\t      return store.dispatch({ type: 'FETCH_ERROR', data: e });\n\t    });\n\t  };\n\t\n\t  riot.route('/top/*', function (category) {\n\t    store.dispatch({ type: 'UPDATE_CATEGORY', data: category });\n\t    _this.fetchCategory(category);\n\t    _this.close();\n\t  });\n\t  riot.route.base('/');\n\t  riot.route.start();\n\t\n\t  this.open = function (item) {\n\t    var state = item.opened;\n\t    this.tags.item.forEach(function (i) {\n\t      return i.opened = false;\n\t    });\n\t    item.opened = !state;\n\t    this.selected = item && item.opened || null;\n\t\n\t    var colorsmap = this.opts.colorchart.get(item.root.querySelector('img'), 2, 10);\n\t    var desc = item.root.querySelector('.description');\n\t    document.body.style.backgroundColor = 'rgb(' + colorsmap[0].join(',') + ')';\n\t    desc.style.color = 'rgb(' + colorsmap[1].join(',') + ')';\n\t  };\n\t\n\t  this.close = function (e) {\n\t    if (e && e.target.href) {\n\t      return true;\n\t    }\n\t    this.tags.item && this.tags.item.forEach(function (i) {\n\t      return i.opened = false;\n\t    });\n\t    this.selected = false;\n\t    document.body.style.backgroundColor = '';\n\t  };\n\t});\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar riot = __webpack_require__(1);\n\t\n\triot.tag2('footer', '<div class=\"align-middle\"> <div>A <a href=\"http://riotjs.com/\" target=\"_blank\">RiotJs</a> Experiment</div> <a href=\"https://github.com/JoTrdl/netflix-top\" target=\"_blank\"><div class=\"github\"></div></a> </div>', '', '', function (opts) {});\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar riot = __webpack_require__(1);\n\t\n\triot.tag2('category', '<select onchange=\"{change}\"> <option each=\"{value, text in options}\" value=\"{value}\" __selected=\"{value==selected}\">{text}</option> </select>', '', '', function (opts) {\n\t\n\t  this.selected = opts.category;\n\t\n\t  this.options = {\n\t    '100': 'Top 100',\n\t    new: 'New Releases',\n\t    action: 'Action & Adventure',\n\t    anime: 'Anime & Animation',\n\t    children: 'Children & Family',\n\t    classic: 'Classics',\n\t    comedy: 'Comedy',\n\t    documentary: 'Documentary',\n\t    drama: 'Drama',\n\t    faith: 'Faith & Spirituality',\n\t    foreign: 'Foreign',\n\t    gay: 'Gay & Lesbian',\n\t    horror: 'Horror',\n\t    independent: 'Independent',\n\t    music: 'Music & Musicals',\n\t    romance: 'Romance',\n\t    fantasy: 'Sci-Fi & Fantasy',\n\t    special: 'Special Interest',\n\t    sports: 'Sports & Fitness',\n\t    shows: 'TV Shows',\n\t    thriller: 'Thrillers'\n\t  };\n\t\n\t  this.change = function (e) {\n\t    riot.route('top/' + e.target.value);\n\t  }.bind(this);\n\t});\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar riot = __webpack_require__(1);\n\t\n\triot.tag2('header', '<div class=\"container\"> <h1 class=\"title\">Netflix <span>TOP</span></h1> <category category=\"{opts.category}\"></category> </div>', '', '', function (opts) {});\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar riot = __webpack_require__(1);\n\t\n\triot.tag2('item', '<img onclick=\"{open}\" data-src=\"{SERVICE_URL + \\'/cover/\\' + data.id}\" src=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\" crossorigin=\"anonymous\"> <div class=\"description\"> <h3>{data.title}</h3> <p>{data.description}</p> <a href=\"{data.link}\" target=\"blank\">{data.link}</a> </div>', '', 'class=\"{opened: opened}\"', function (opts) {\n\t  var _this = this;\n\t\n\t  var isServer = !!(typeof window === 'undefined');\n\t\n\t  this.data = opts.data;\n\t  this.opened = false;\n\t\n\t  open = function open(e) {\n\t    e.stopImmediatePropagation();\n\t    this.parent.open(this);\n\t  };\n\t\n\t  this.lazyload = function () {\n\t    var rect = _this.root.getBoundingClientRect();\n\t\n\t    var inView = rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) + 300 && rect.right <= (window.innerWidth || document.documentElement.clientWidth);\n\t\n\t    if (inView) {\n\t      _this.img.setAttribute('src', _this.img.getAttribute('data-src'));\n\t      window.removeEventListener('scroll', _this.lazyload);\n\t      window.removeEventListener('resize', _this.lazyload);\n\t    }\n\t  };\n\t\n\t  this.on('mount', function () {\n\t    var _this2 = this;\n\t\n\t    if (isServer) return;\n\t\n\t    this.img = this.root.querySelector('img');\n\t    document.addEventListener('scroll', this.lazyload);\n\t    document.addEventListener('resize', this.lazyload);\n\t    setTimeout(function () {\n\t      return _this2.lazyload();\n\t    });\n\t  });\n\t\n\t  this.on('unmount', function () {\n\t    if (isServer) return;\n\t    window.removeEventListener('scroll', this.lazyload);\n\t    window.removeEventListener('resize', this.lazyload);\n\t  });\n\t});\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar redux = __webpack_require__(26);\n\tvar INITIAL_STATE = typeof STORE != 'undefined' ? STORE : {\n\t  title: '',\n\t  category: '',\n\t  rendered: false,\n\t  items: {\n\t    isFetching: false,\n\t    hasError: false,\n\t    data: []\n\t  }\n\t};\n\t\n\tvar actions = {\n\t  'UPDATE_TITLE': function UPDATE_TITLE(state, action) {\n\t    return Object.assign({}, state, { title: action.data });\n\t  },\n\t  'SERVER_RENDERED': function SERVER_RENDERED(state, action) {\n\t    return Object.assign({}, state, { rendered: true });\n\t  },\n\t  'UPDATE_CATEGORY': function UPDATE_CATEGORY(state, action) {\n\t    return Object.assign({}, state, { category: action.data });\n\t  },\n\t  'FETCH_INIT': function FETCH_INIT(state, action) {\n\t    return Object.assign({}, state, {\n\t      items: {\n\t        isFetching: true,\n\t        hasError: false\n\t      }\n\t    });\n\t  },\n\t  'FETCH_SUCCESS': function FETCH_SUCCESS(state, action) {\n\t    return Object.assign({}, state, {\n\t      title: action.data.title,\n\t      items: {\n\t        isFetching: false,\n\t        hasError: false,\n\t        data: action.data.items\n\t      }\n\t    });\n\t  },\n\t  'FETCH_ERROR': function FETCH_ERROR(state, action) {\n\t    return Object.assign({}, state, {\n\t      items: {\n\t        isFetching: false,\n\t        hasError: true,\n\t        data: action.data\n\t      }\n\t    });\n\t  }\n\t};\n\t\n\tvar reducer = function reducer(state, action) {\n\t  var update = actions[action.type] && actions[action.type](state, action) || null;\n\t  return update || state || INITIAL_STATE;\n\t};\n\t\n\tmodule.exports = redux.createStore(reducer);\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = Canvas;\n\t\n\tfunction Canvas(img){\n\t  if(!(this instanceof Canvas)){\n\t    return new Canvas();\n\t  }\n\t\n\t  this.canvas  = document.createElement('canvas');\n\t  this.context = this.canvas.getContext('2d');\n\t\n\t  document.body.appendChild(this.canvas);\n\t\n\t  this.width  = this.canvas.width  = img.width;\n\t  this.height = this.canvas.height = img.height;\n\t  this.context.drawImage(img, 0, 0, this.width, this.height);\n\t}\n\t\n\tCanvas.prototype.getSize = function(){\n\t  return this.width * this.height;\n\t}\n\t\n\tCanvas.prototype.getData = function(){\n\t  return this.context.getImageData(0, 0, this.width, this.height);\n\t}\n\t\n\tCanvas.prototype.delete = function(){\n\t  this.canvas.parentNode.removeChild(this.canvas);\n\t}\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar quantize = __webpack_require__(14);\n\tvar Canvas = __webpack_require__(12);\n\t\n\tmodule.exports = Colormap;\n\t\n\tfunction Colormap(){\n\t  if(!(this instanceof Colormap)){\n\t    return new Colormap();\n\t  }\n\t}\n\t\n\tColormap.prototype.get = function(img, count, quality){\n\t  var mapQuality = quality || 10;\n\t  var colorCount = count;\n\t\n\t  if(!count || count == '1'){\n\t    colorCount = 5;\n\t  }\n\t\n\t  var canvas = new Canvas(img);\n\t  var canvasData = canvas.getData();\n\t  var pixels = canvasData.data;\n\t  var size = canvas.getSize();\n\t\n\t  // canvas RGB values in an array format suitable for quantize function\n\t  var rgbArray = [];\n\t\n\t  for (var i = 0, offset, r, g, b, a; i < size; i = i + mapQuality) {\n\t    offset = i * 4;\n\t    r = pixels[offset + 0];\n\t    g = pixels[offset + 1];\n\t    b = pixels[offset + 2];\n\t    a = pixels[offset + 3];\n\t\n\t    // if a pixel is mostly opaque and not white\n\t    if (a >= 125) {\n\t      if (!(r > 250 && g > 250 && b > 250)) {\n\t        rgbArray.push([r, g, b]);\n\t      }\n\t    }\n\t  }\n\t\n\t  var result = quantize(rgbArray, colorCount);\n\t  canvas.delete();\n\t\n\t  return result.palette().slice(0, count);\n\t}\n\t\n\tColormap.prototype.getDominant = function(img){\n\t  return this.get(img, 1)[0];\n\t}\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/*\n\t * quantize.js Copyright 2008 Nick Rabinowitz\n\t * Ported to node.js by Olivier Lesnicki\n\t * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n\t */\n\t\n\t// fill out a couple protovis dependencies\n\t/*\n\t * Block below copied from Protovis: http://mbostock.github.com/protovis/\n\t * Copyright 2010 Stanford Visualization Group\n\t * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n\t */\n\tif (!pv) {\n\t    var pv = {\n\t        map: function(array, f) {\n\t            var o = {};\n\t            return f ? array.map(function(d, i) {\n\t                o.index = i;\n\t                return f.call(o, d);\n\t            }) : array.slice();\n\t        },\n\t        naturalOrder: function(a, b) {\n\t            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n\t        },\n\t        sum: function(array, f) {\n\t            var o = {};\n\t            return array.reduce(f ? function(p, d, i) {\n\t                o.index = i;\n\t                return p + f.call(o, d);\n\t            } : function(p, d) {\n\t                return p + d;\n\t            }, 0);\n\t        },\n\t        max: function(array, f) {\n\t            return Math.max.apply(null, f ? pv.map(array, f) : array);\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * Basic Javascript port of the MMCQ (modified median cut quantization)\n\t * algorithm from the Leptonica library (http://www.leptonica.com/).\n\t * Returns a color map you can use to map original pixels to the reduced\n\t * palette. Still a work in progress.\n\t * \n\t * @author Nick Rabinowitz\n\t * @example\n\t \n\t// array of pixels as [R,G,B] arrays\n\tvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n\t                // etc\n\t                ];\n\tvar maxColors = 4;\n\t \n\tvar cmap = MMCQ.quantize(myPixels, maxColors);\n\tvar newPalette = cmap.palette();\n\tvar newPixels = myPixels.map(function(p) { \n\t    return cmap.map(p); \n\t});\n\t \n\t */\n\tvar MMCQ = (function() {\n\t    // private constants\n\t    var sigbits = 5,\n\t        rshift = 8 - sigbits,\n\t        maxIterations = 1000,\n\t        fractByPopulations = 0.75;\n\t\n\t    // get reduced-space color index for a pixel\n\t\n\t    function getColorIndex(r, g, b) {\n\t        return (r << (2 * sigbits)) + (g << sigbits) + b;\n\t    }\n\t\n\t    // Simple priority queue\n\t\n\t    function PQueue(comparator) {\n\t        var contents = [],\n\t            sorted = false;\n\t\n\t        function sort() {\n\t            contents.sort(comparator);\n\t            sorted = true;\n\t        }\n\t\n\t        return {\n\t            push: function(o) {\n\t                contents.push(o);\n\t                sorted = false;\n\t            },\n\t            peek: function(index) {\n\t                if (!sorted) sort();\n\t                if (index === undefined) index = contents.length - 1;\n\t                return contents[index];\n\t            },\n\t            pop: function() {\n\t                if (!sorted) sort();\n\t                return contents.pop();\n\t            },\n\t            size: function() {\n\t                return contents.length;\n\t            },\n\t            map: function(f) {\n\t                return contents.map(f);\n\t            },\n\t            debug: function() {\n\t                if (!sorted) sort();\n\t                return contents;\n\t            }\n\t        };\n\t    }\n\t\n\t    // 3d color space box\n\t\n\t    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n\t        var vbox = this;\n\t        vbox.r1 = r1;\n\t        vbox.r2 = r2;\n\t        vbox.g1 = g1;\n\t        vbox.g2 = g2;\n\t        vbox.b1 = b1;\n\t        vbox.b2 = b2;\n\t        vbox.histo = histo;\n\t    }\n\t    VBox.prototype = {\n\t        volume: function(force) {\n\t            var vbox = this;\n\t            if (!vbox._volume || force) {\n\t                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n\t            }\n\t            return vbox._volume;\n\t        },\n\t        count: function(force) {\n\t            var vbox = this,\n\t                histo = vbox.histo;\n\t            if (!vbox._count_set || force) {\n\t                var npix = 0,\n\t                    i, j, k, index;\n\t                for (i = vbox.r1; i <= vbox.r2; i++) {\n\t                    for (j = vbox.g1; j <= vbox.g2; j++) {\n\t                        for (k = vbox.b1; k <= vbox.b2; k++) {\n\t                            index = getColorIndex(i, j, k);\n\t                            npix += (histo[index] || 0);\n\t                        }\n\t                    }\n\t                }\n\t                vbox._count = npix;\n\t                vbox._count_set = true;\n\t            }\n\t            return vbox._count;\n\t        },\n\t        copy: function() {\n\t            var vbox = this;\n\t            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n\t        },\n\t        avg: function(force) {\n\t            var vbox = this,\n\t                histo = vbox.histo;\n\t            if (!vbox._avg || force) {\n\t                var ntot = 0,\n\t                    mult = 1 << (8 - sigbits),\n\t                    rsum = 0,\n\t                    gsum = 0,\n\t                    bsum = 0,\n\t                    hval,\n\t                    i, j, k, histoindex;\n\t                for (i = vbox.r1; i <= vbox.r2; i++) {\n\t                    for (j = vbox.g1; j <= vbox.g2; j++) {\n\t                        for (k = vbox.b1; k <= vbox.b2; k++) {\n\t                            histoindex = getColorIndex(i, j, k);\n\t                            hval = histo[histoindex] || 0;\n\t                            ntot += hval;\n\t                            rsum += (hval * (i + 0.5) * mult);\n\t                            gsum += (hval * (j + 0.5) * mult);\n\t                            bsum += (hval * (k + 0.5) * mult);\n\t                        }\n\t                    }\n\t                }\n\t                if (ntot) {\n\t                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\n\t                } else {\n\t                    //console.log('empty box');\n\t                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n\t                }\n\t            }\n\t            return vbox._avg;\n\t        },\n\t        contains: function(pixel) {\n\t            var vbox = this,\n\t                rval = pixel[0] >> rshift;\n\t            gval = pixel[1] >> rshift;\n\t            bval = pixel[2] >> rshift;\n\t            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n\t                gval >= vbox.g1 && gval <= vbox.g2 &&\n\t                bval >= vbox.b1 && bval <= vbox.b2);\n\t        }\n\t    };\n\t\n\t    // Color map\n\t\n\t    function CMap() {\n\t        this.vboxes = new PQueue(function(a, b) {\n\t            return pv.naturalOrder(\n\t                a.vbox.count() * a.vbox.volume(),\n\t                b.vbox.count() * b.vbox.volume()\n\t            )\n\t        });;\n\t    }\n\t    CMap.prototype = {\n\t        push: function(vbox) {\n\t            this.vboxes.push({\n\t                vbox: vbox,\n\t                color: vbox.avg()\n\t            });\n\t        },\n\t        palette: function() {\n\t            return this.vboxes.map(function(vb) {\n\t                return vb.color\n\t            });\n\t        },\n\t        size: function() {\n\t            return this.vboxes.size();\n\t        },\n\t        map: function(color) {\n\t            var vboxes = this.vboxes;\n\t            for (var i = 0; i < vboxes.size(); i++) {\n\t                if (vboxes.peek(i).vbox.contains(color)) {\n\t                    return vboxes.peek(i).color;\n\t                }\n\t            }\n\t            return this.nearest(color);\n\t        },\n\t        nearest: function(color) {\n\t            var vboxes = this.vboxes,\n\t                d1, d2, pColor;\n\t            for (var i = 0; i < vboxes.size(); i++) {\n\t                d2 = Math.sqrt(\n\t                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n\t                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n\t                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n\t                );\n\t                if (d2 < d1 || d1 === undefined) {\n\t                    d1 = d2;\n\t                    pColor = vboxes.peek(i).color;\n\t                }\n\t            }\n\t            return pColor;\n\t        },\n\t        forcebw: function() {\n\t            // XXX: won't  work yet\n\t            var vboxes = this.vboxes;\n\t            vboxes.sort(function(a, b) {\n\t                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\n\t            });\n\t\n\t            // force darkest color to black if everything < 5\n\t            var lowest = vboxes[0].color;\n\t            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n\t                vboxes[0].color = [0, 0, 0];\n\t\n\t            // force lightest color to white if everything > 251\n\t            var idx = vboxes.length - 1,\n\t                highest = vboxes[idx].color;\n\t            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n\t                vboxes[idx].color = [255, 255, 255];\n\t        }\n\t    };\n\t\n\t    // histo (1-d array, giving the number of pixels in\n\t    // each quantized region of color space), or null on error\n\t\n\t    function getHisto(pixels) {\n\t        var histosize = 1 << (3 * sigbits),\n\t            histo = new Array(histosize),\n\t            index, rval, gval, bval;\n\t        pixels.forEach(function(pixel) {\n\t            rval = pixel[0] >> rshift;\n\t            gval = pixel[1] >> rshift;\n\t            bval = pixel[2] >> rshift;\n\t            index = getColorIndex(rval, gval, bval);\n\t            histo[index] = (histo[index] || 0) + 1;\n\t        });\n\t        return histo;\n\t    }\n\t\n\t    function vboxFromPixels(pixels, histo) {\n\t        var rmin = 1000000,\n\t            rmax = 0,\n\t            gmin = 1000000,\n\t            gmax = 0,\n\t            bmin = 1000000,\n\t            bmax = 0,\n\t            rval, gval, bval;\n\t        // find min/max\n\t        pixels.forEach(function(pixel) {\n\t            rval = pixel[0] >> rshift;\n\t            gval = pixel[1] >> rshift;\n\t            bval = pixel[2] >> rshift;\n\t            if (rval < rmin) rmin = rval;\n\t            else if (rval > rmax) rmax = rval;\n\t            if (gval < gmin) gmin = gval;\n\t            else if (gval > gmax) gmax = gval;\n\t            if (bval < bmin) bmin = bval;\n\t            else if (bval > bmax) bmax = bval;\n\t        });\n\t        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n\t    }\n\t\n\t    function medianCutApply(histo, vbox) {\n\t        if (!vbox.count()) return;\n\t\n\t        var rw = vbox.r2 - vbox.r1 + 1,\n\t            gw = vbox.g2 - vbox.g1 + 1,\n\t            bw = vbox.b2 - vbox.b1 + 1,\n\t            maxw = pv.max([rw, gw, bw]);\n\t        // only one pixel, no split\n\t        if (vbox.count() == 1) {\n\t            return [vbox.copy()]\n\t        }\n\t        /* Find the partial sum arrays along the selected axis. */\n\t        var total = 0,\n\t            partialsum = [],\n\t            lookaheadsum = [],\n\t            i, j, k, sum, index;\n\t        if (maxw == rw) {\n\t            for (i = vbox.r1; i <= vbox.r2; i++) {\n\t                sum = 0;\n\t                for (j = vbox.g1; j <= vbox.g2; j++) {\n\t                    for (k = vbox.b1; k <= vbox.b2; k++) {\n\t                        index = getColorIndex(i, j, k);\n\t                        sum += (histo[index] || 0);\n\t                    }\n\t                }\n\t                total += sum;\n\t                partialsum[i] = total;\n\t            }\n\t        } else if (maxw == gw) {\n\t            for (i = vbox.g1; i <= vbox.g2; i++) {\n\t                sum = 0;\n\t                for (j = vbox.r1; j <= vbox.r2; j++) {\n\t                    for (k = vbox.b1; k <= vbox.b2; k++) {\n\t                        index = getColorIndex(j, i, k);\n\t                        sum += (histo[index] || 0);\n\t                    }\n\t                }\n\t                total += sum;\n\t                partialsum[i] = total;\n\t            }\n\t        } else { /* maxw == bw */\n\t            for (i = vbox.b1; i <= vbox.b2; i++) {\n\t                sum = 0;\n\t                for (j = vbox.r1; j <= vbox.r2; j++) {\n\t                    for (k = vbox.g1; k <= vbox.g2; k++) {\n\t                        index = getColorIndex(j, k, i);\n\t                        sum += (histo[index] || 0);\n\t                    }\n\t                }\n\t                total += sum;\n\t                partialsum[i] = total;\n\t            }\n\t        }\n\t        partialsum.forEach(function(d, i) {\n\t            lookaheadsum[i] = total - d\n\t        });\n\t\n\t        function doCut(color) {\n\t            var dim1 = color + '1',\n\t                dim2 = color + '2',\n\t                left, right, vbox1, vbox2, d2, count2 = 0;\n\t            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n\t                if (partialsum[i] > total / 2) {\n\t                    vbox1 = vbox.copy();\n\t                    vbox2 = vbox.copy();\n\t                    left = i - vbox[dim1];\n\t                    right = vbox[dim2] - i;\n\t                    if (left <= right)\n\t                        d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\n\t                    else d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\n\t                    // avoid 0-count boxes\n\t                    while (!partialsum[d2]) d2++;\n\t                    count2 = lookaheadsum[d2];\n\t                    while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\n\t                    // set dimensions\n\t                    vbox1[dim2] = d2;\n\t                    vbox2[dim1] = vbox1[dim2] + 1;\n\t                    // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n\t                    return [vbox1, vbox2];\n\t                }\n\t            }\n\t\n\t        }\n\t        // determine the cut planes\n\t        return maxw == rw ? doCut('r') :\n\t            maxw == gw ? doCut('g') :\n\t            doCut('b');\n\t    }\n\t\n\t    function quantize(pixels, maxcolors) {\n\t        // short-circuit\n\t        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n\t            // console.log('wrong number of maxcolors');\n\t            return false;\n\t        }\n\t\n\t        // XXX: check color content and convert to grayscale if insufficient\n\t\n\t        var histo = getHisto(pixels),\n\t            histosize = 1 << (3 * sigbits);\n\t\n\t        // check that we aren't below maxcolors already\n\t        var nColors = 0;\n\t        histo.forEach(function() {\n\t            nColors++\n\t        });\n\t        if (nColors <= maxcolors) {\n\t            // XXX: generate the new colors from the histo and return\n\t        }\n\t\n\t        // get the beginning vbox from the colors\n\t        var vbox = vboxFromPixels(pixels, histo),\n\t            pq = new PQueue(function(a, b) {\n\t                return pv.naturalOrder(a.count(), b.count())\n\t            });\n\t        pq.push(vbox);\n\t\n\t        // inner function to do the iteration\n\t\n\t        function iter(lh, target) {\n\t            var ncolors = 1,\n\t                niters = 0,\n\t                vbox;\n\t            while (niters < maxIterations) {\n\t                vbox = lh.pop();\n\t                if (!vbox.count()) { /* just put it back */\n\t                    lh.push(vbox);\n\t                    niters++;\n\t                    continue;\n\t                }\n\t                // do the cut\n\t                var vboxes = medianCutApply(histo, vbox),\n\t                    vbox1 = vboxes[0],\n\t                    vbox2 = vboxes[1];\n\t\n\t                if (!vbox1) {\n\t                    // console.log(\"vbox1 not defined; shouldn't happen!\");\n\t                    return;\n\t                }\n\t                lh.push(vbox1);\n\t                if (vbox2) { /* vbox2 can be null */\n\t                    lh.push(vbox2);\n\t                    ncolors++;\n\t                }\n\t                if (ncolors >= target) return;\n\t                if (niters++ > maxIterations) {\n\t                    // console.log(\"infinite loop; perhaps too few pixels!\");\n\t                    return;\n\t                }\n\t            }\n\t        }\n\t\n\t        // first set of colors, sorted by population\n\t        iter(pq, fractByPopulations * maxcolors);\n\t        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n\t\n\t        // Re-sort by the product of pixel occupancy times the size in color space.\n\t        var pq2 = new PQueue(function(a, b) {\n\t            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\n\t        });\n\t        while (pq.size()) {\n\t            pq2.push(pq.pop());\n\t        }\n\t\n\t        // next set - generate the median cuts using the (npix * vol) sorting.\n\t        iter(pq2, maxcolors - pq2.size());\n\t\n\t        // calculate the actual colors\n\t        var cmap = new CMap();\n\t        while (pq2.size()) {\n\t            cmap.push(pq2.pop());\n\t        }\n\t\n\t        return cmap;\n\t    }\n\t\n\t    return {\n\t        quantize: quantize\n\t    }\n\t})();\n\t\n\tmodule.exports = MMCQ.quantize\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 16 */\n15,\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// the whatwg-fetch polyfill installs the fetch() function\n\t// on the global object (window or self)\n\t//\n\t// Return that as the export for use in Webpack, Browserify etc.\n\t__webpack_require__(18);\n\tmodule.exports = self.fetch.bind(self);\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t(function(self) {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  var support = {\n\t    searchParams: 'URLSearchParams' in self,\n\t    iterable: 'Symbol' in self && 'iterator' in Symbol,\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob()\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self,\n\t    arrayBuffer: 'ArrayBuffer' in self\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  // Build a destructive iterator for the value list\n\t  function iteratorFor(items) {\n\t    var iterator = {\n\t      next: function() {\n\t        var value = items.shift()\n\t        return {done: value === undefined, value: value}\n\t      }\n\t    }\n\t\n\t    if (support.iterable) {\n\t      iterator[Symbol.iterator] = function() {\n\t        return iterator\n\t      }\n\t    }\n\t\n\t    return iterator\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var list = this.map[name]\n\t    if (!list) {\n\t      list = []\n\t      this.map[name] = list\n\t    }\n\t    list.push(value)\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    var values = this.map[normalizeName(name)]\n\t    return values ? values[0] : null\n\t  }\n\t\n\t  Headers.prototype.getAll = function(name) {\n\t    return this.map[normalizeName(name)] || []\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = [normalizeValue(value)]\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n\t      this.map[name].forEach(function(value) {\n\t        callback.call(thisArg, value, name, this)\n\t      }, this)\n\t    }, this)\n\t  }\n\t\n\t  Headers.prototype.keys = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push(name) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.values = function() {\n\t    var items = []\n\t    this.forEach(function(value) { items.push(value) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.entries = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push([name, value]) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  if (support.iterable) {\n\t    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsArrayBuffer(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsText(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t        this._bodyText = body.toString()\n\t      } else if (!body) {\n\t        this._bodyText = ''\n\t      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n\t        // Only support ArrayBuffers for POST method.\n\t        // Receiving ArrayBuffers happens via Blobs, instead.\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t\n\t      if (!this.headers.get('content-type')) {\n\t        if (typeof body === 'string') {\n\t          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n\t        } else if (this._bodyBlob && this._bodyBlob.type) {\n\t          this.headers.set('content-type', this._bodyBlob.type)\n\t        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n\t        }\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        return this.blob().then(readBlobAsArrayBuffer)\n\t      }\n\t\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return readBlobAsText(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as text')\n\t        } else {\n\t          return Promise.resolve(this._bodyText)\n\t        }\n\t      }\n\t    } else {\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        return rejected ? rejected : Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t    if (Request.prototype.isPrototypeOf(input)) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = input\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  Request.prototype.clone = function() {\n\t    return new Request(this)\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function headers(xhr) {\n\t    var head = new Headers()\n\t    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\\n')\n\t    pairs.forEach(function(header) {\n\t      var split = header.trim().split(':')\n\t      var key = split.shift().trim()\n\t      var value = split.join(':').trim()\n\t      head.append(key, value)\n\t    })\n\t    return head\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this.type = 'default'\n\t    this.status = options.status\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = options.statusText\n\t    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n\t    this.url = options.url || ''\n\t    this._initBody(bodyInit)\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  Response.prototype.clone = function() {\n\t    return new Response(this._bodyInit, {\n\t      status: this.status,\n\t      statusText: this.statusText,\n\t      headers: new Headers(this.headers),\n\t      url: this.url\n\t    })\n\t  }\n\t\n\t  Response.error = function() {\n\t    var response = new Response(null, {status: 0, statusText: ''})\n\t    response.type = 'error'\n\t    return response\n\t  }\n\t\n\t  var redirectStatuses = [301, 302, 303, 307, 308]\n\t\n\t  Response.redirect = function(url, status) {\n\t    if (redirectStatuses.indexOf(status) === -1) {\n\t      throw new RangeError('Invalid status code')\n\t    }\n\t\n\t    return new Response(null, {status: status, headers: {location: url}})\n\t  }\n\t\n\t  self.Headers = Headers\n\t  self.Request = Request\n\t  self.Response = Response\n\t\n\t  self.fetch = function(input, init) {\n\t    return new Promise(function(resolve, reject) {\n\t      var request\n\t      if (Request.prototype.isPrototypeOf(input) && !init) {\n\t        request = input\n\t      } else {\n\t        request = new Request(input, init)\n\t      }\n\t\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      function responseURL() {\n\t        if ('responseURL' in xhr) {\n\t          return xhr.responseURL\n\t        }\n\t\n\t        // Avoid security warnings on getResponseHeader when not allowed by CORS\n\t        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n\t          return xhr.getResponseHeader('X-Request-URL')\n\t        }\n\t\n\t        return\n\t      }\n\t\n\t      xhr.onload = function() {\n\t        var options = {\n\t          status: xhr.status,\n\t          statusText: xhr.statusText,\n\t          headers: headers(xhr),\n\t          url: responseURL()\n\t        }\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.ontimeout = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeGetPrototype = Object.getPrototypeOf;\n\t\n\t/**\n\t * Gets the `[[Prototype]]` of `value`.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {null|Object} Returns the `[[Prototype]]`.\n\t */\n\tfunction getPrototype(value) {\n\t  return nativeGetPrototype(Object(value));\n\t}\n\t\n\tmodule.exports = getPrototype;\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Checks if `value` is a host object in IE < 9.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n\t */\n\tfunction isHostObject(value) {\n\t  // Many host objects are `Object` objects that can coerce to strings\n\t  // despite having improperly defined `toString` methods.\n\t  var result = false;\n\t  if (value != null && typeof value.toString != 'function') {\n\t    try {\n\t      result = !!(value + '');\n\t    } catch (e) {}\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = isHostObject;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\t\n\tmodule.exports = isObjectLike;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tvar appCacheIframe;\n\t\n\tfunction hasSW() {\n\t  return 'serviceWorker' in navigator &&\n\t    // This is how I block Chrome 40 and detect Chrome 41, because first has\n\t    // bugs with history.pustState and/or hashchange\n\t    (window.fetch || 'imageRendering' in document.documentElement.style) &&\n\t    (window.location.protocol === 'https:' || window.location.hostname === 'localhost')\n\t}\n\t\n\tfunction install(options) {\n\t  options || (options = {});\n\t\n\t  \n\t    if (hasSW()) {\n\t      var registration = navigator.serviceWorker\n\t        .register(\"/sw.js\");\n\t\n\t      \n\t\n\t      return;\n\t    }\n\t  \n\t\n\t  \n\t    if (window.applicationCache) {\n\t      var directory = \"/appcache/\";\n\t      var name = \"manifest\";\n\t\n\t      var doLoad = function() {\n\t        var page = directory + name + '.html';\n\t        var iframe = document.createElement('iframe');\n\t\n\t        \n\t\n\t        iframe.src = page;\n\t        iframe.style.display = 'none';\n\t\n\t        appCacheIframe = iframe;\n\t        document.body.appendChild(iframe);\n\t      };\n\t\n\t      if (document.readyState === 'complete') {\n\t        setTimeout(doLoad);\n\t      } else {\n\t        window.addEventListener('load', doLoad);\n\t      }\n\t\n\t      return;\n\t    }\n\t  \n\t}\n\t\n\tfunction applyUpdate(callback, errback) {\n\t  \n\t\n\t  \n\t}\n\t\n\texports.install = install;\n\texports.applyUpdate = applyUpdate;\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\texports[\"default\"] = applyMiddleware;\n\t\n\tvar _compose = __webpack_require__(3);\n\t\n\tvar _compose2 = _interopRequireDefault(_compose);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\t/**\n\t * Creates a store enhancer that applies middleware to the dispatch method\n\t * of the Redux store. This is handy for a variety of tasks, such as expressing\n\t * asynchronous actions in a concise manner, or logging every action payload.\n\t *\n\t * See `redux-thunk` package as an example of the Redux middleware.\n\t *\n\t * Because middleware is potentially asynchronous, this should be the first\n\t * store enhancer in the composition chain.\n\t *\n\t * Note that each middleware will be given the `dispatch` and `getState` functions\n\t * as named arguments.\n\t *\n\t * @param {...Function} middlewares The middleware chain to be applied.\n\t * @returns {Function} A store enhancer applying the middleware.\n\t */\n\tfunction applyMiddleware() {\n\t  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n\t    middlewares[_key] = arguments[_key];\n\t  }\n\t\n\t  return function (createStore) {\n\t    return function (reducer, initialState, enhancer) {\n\t      var store = createStore(reducer, initialState, enhancer);\n\t      var _dispatch = store.dispatch;\n\t      var chain = [];\n\t\n\t      var middlewareAPI = {\n\t        getState: store.getState,\n\t        dispatch: function dispatch(action) {\n\t          return _dispatch(action);\n\t        }\n\t      };\n\t      chain = middlewares.map(function (middleware) {\n\t        return middleware(middlewareAPI);\n\t      });\n\t      _dispatch = _compose2[\"default\"].apply(undefined, chain)(store.dispatch);\n\t\n\t      return _extends({}, store, {\n\t        dispatch: _dispatch\n\t      });\n\t    };\n\t  };\n\t}\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = bindActionCreators;\n\tfunction bindActionCreator(actionCreator, dispatch) {\n\t  return function () {\n\t    return dispatch(actionCreator.apply(undefined, arguments));\n\t  };\n\t}\n\t\n\t/**\n\t * Turns an object whose values are action creators, into an object with the\n\t * same keys, but with every function wrapped into a `dispatch` call so they\n\t * may be invoked directly. This is just a convenience method, as you can call\n\t * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n\t *\n\t * For convenience, you can also pass a single function as the first argument,\n\t * and get a function in return.\n\t *\n\t * @param {Function|Object} actionCreators An object whose values are action\n\t * creator functions. One handy way to obtain it is to use ES6 `import * as`\n\t * syntax. You may also pass a single function.\n\t *\n\t * @param {Function} dispatch The `dispatch` function available on your Redux\n\t * store.\n\t *\n\t * @returns {Function|Object} The object mimicking the original object, but with\n\t * every action creator wrapped into the `dispatch` call. If you passed a\n\t * function as `actionCreators`, the return value will also be a single\n\t * function.\n\t */\n\tfunction bindActionCreators(actionCreators, dispatch) {\n\t  if (typeof actionCreators === 'function') {\n\t    return bindActionCreator(actionCreators, dispatch);\n\t  }\n\t\n\t  if (typeof actionCreators !== 'object' || actionCreators === null) {\n\t    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n\t  }\n\t\n\t  var keys = Object.keys(actionCreators);\n\t  var boundActionCreators = {};\n\t  for (var i = 0; i < keys.length; i++) {\n\t    var key = keys[i];\n\t    var actionCreator = actionCreators[key];\n\t    if (typeof actionCreator === 'function') {\n\t      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n\t    }\n\t  }\n\t  return boundActionCreators;\n\t}\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = combineReducers;\n\t\n\tvar _createStore = __webpack_require__(4);\n\t\n\tvar _isPlainObject = __webpack_require__(2);\n\t\n\tvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\t\n\tvar _warning = __webpack_require__(5);\n\t\n\tvar _warning2 = _interopRequireDefault(_warning);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\tfunction getUndefinedStateErrorMessage(key, action) {\n\t  var actionType = action && action.type;\n\t  var actionName = actionType && '\"' + actionType.toString() + '\"' || 'an action';\n\t\n\t  return 'Given action ' + actionName + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';\n\t}\n\t\n\tfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {\n\t  var reducerKeys = Object.keys(reducers);\n\t  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';\n\t\n\t  if (reducerKeys.length === 0) {\n\t    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n\t  }\n\t\n\t  if (!(0, _isPlainObject2[\"default\"])(inputState)) {\n\t    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n\t  }\n\t\n\t  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n\t    return !reducers.hasOwnProperty(key);\n\t  });\n\t\n\t  if (unexpectedKeys.length > 0) {\n\t    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n\t  }\n\t}\n\t\n\tfunction assertReducerSanity(reducers) {\n\t  Object.keys(reducers).forEach(function (key) {\n\t    var reducer = reducers[key];\n\t    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });\n\t\n\t    if (typeof initialState === 'undefined') {\n\t      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');\n\t    }\n\t\n\t    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n\t    if (typeof reducer(undefined, { type: type }) === 'undefined') {\n\t      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Turns an object whose values are different reducer functions, into a single\n\t * reducer function. It will call every child reducer, and gather their results\n\t * into a single state object, whose keys correspond to the keys of the passed\n\t * reducer functions.\n\t *\n\t * @param {Object} reducers An object whose values correspond to different\n\t * reducer functions that need to be combined into one. One handy way to obtain\n\t * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n\t * undefined for any action. Instead, they should return their initial state\n\t * if the state passed to them was undefined, and the current state for any\n\t * unrecognized action.\n\t *\n\t * @returns {Function} A reducer function that invokes every reducer inside the\n\t * passed object, and builds a state object with the same shape.\n\t */\n\tfunction combineReducers(reducers) {\n\t  var reducerKeys = Object.keys(reducers);\n\t  var finalReducers = {};\n\t  for (var i = 0; i < reducerKeys.length; i++) {\n\t    var key = reducerKeys[i];\n\t    if (typeof reducers[key] === 'function') {\n\t      finalReducers[key] = reducers[key];\n\t    }\n\t  }\n\t  var finalReducerKeys = Object.keys(finalReducers);\n\t\n\t  var sanityError;\n\t  try {\n\t    assertReducerSanity(finalReducers);\n\t  } catch (e) {\n\t    sanityError = e;\n\t  }\n\t\n\t  return function combination() {\n\t    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    var action = arguments[1];\n\t\n\t    if (sanityError) {\n\t      throw sanityError;\n\t    }\n\t\n\t    if (false) {\n\t      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);\n\t      if (warningMessage) {\n\t        (0, _warning2[\"default\"])(warningMessage);\n\t      }\n\t    }\n\t\n\t    var hasChanged = false;\n\t    var nextState = {};\n\t    for (var i = 0; i < finalReducerKeys.length; i++) {\n\t      var key = finalReducerKeys[i];\n\t      var reducer = finalReducers[key];\n\t      var previousStateForKey = state[key];\n\t      var nextStateForKey = reducer(previousStateForKey, action);\n\t      if (typeof nextStateForKey === 'undefined') {\n\t        var errorMessage = getUndefinedStateErrorMessage(key, action);\n\t        throw new Error(errorMessage);\n\t      }\n\t      nextState[key] = nextStateForKey;\n\t      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n\t    }\n\t    return hasChanged ? nextState : state;\n\t  };\n\t}\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;\n\t\n\tvar _createStore = __webpack_require__(4);\n\t\n\tvar _createStore2 = _interopRequireDefault(_createStore);\n\t\n\tvar _combineReducers = __webpack_require__(25);\n\t\n\tvar _combineReducers2 = _interopRequireDefault(_combineReducers);\n\t\n\tvar _bindActionCreators = __webpack_require__(24);\n\t\n\tvar _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);\n\t\n\tvar _applyMiddleware = __webpack_require__(23);\n\t\n\tvar _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);\n\t\n\tvar _compose = __webpack_require__(3);\n\t\n\tvar _compose2 = _interopRequireDefault(_compose);\n\t\n\tvar _warning = __webpack_require__(5);\n\t\n\tvar _warning2 = _interopRequireDefault(_warning);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\t/*\n\t* This is a dummy function to check if the function name has been altered by minification.\n\t* If the function has been minified and NODE_ENV !== 'production', warn the user.\n\t*/\n\tfunction isCrushed() {}\n\t\n\tif (false) {\n\t  (0, _warning2[\"default\"])('You are currently using minified code outside of NODE_ENV === \\'production\\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');\n\t}\n\t\n\texports.createStore = _createStore2[\"default\"];\n\texports.combineReducers = _combineReducers2[\"default\"];\n\texports.bindActionCreators = _bindActionCreators2[\"default\"];\n\texports.applyMiddleware = _applyMiddleware2[\"default\"];\n\texports.compose = _compose2[\"default\"];\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/* global window */\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(28)(global || window || this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function symbolObservablePonyfill(root) {\n\t\tvar result;\n\t\tvar Symbol = root.Symbol;\n\t\n\t\tif (typeof Symbol === 'function') {\n\t\t\tif (Symbol.observable) {\n\t\t\t\tresult = Symbol.observable;\n\t\t\t} else {\n\t\t\t\tresult = Symbol('observable');\n\t\t\t\tSymbol.observable = result;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = '@@observable';\n\t\t}\n\t\n\t\treturn result;\n\t};\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar map = {\n\t\t\"./app.tag\": 6,\n\t\t\"./footer.tag\": 7,\n\t\t\"./header/category.tag\": 8,\n\t\t\"./header/header.tag\": 9,\n\t\t\"./item.tag\": 10\n\t};\n\tfunction webpackContext(req) {\n\t\treturn __webpack_require__(webpackContextResolve(req));\n\t};\n\tfunction webpackContextResolve(req) {\n\t\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n\t};\n\twebpackContext.keys = function webpackContextKeys() {\n\t\treturn Object.keys(map);\n\t};\n\twebpackContext.resolve = webpackContextResolve;\n\tmodule.exports = webpackContext;\n\twebpackContext.id = 30;\n\n\n/***/ }\n/******/ ])));\n\n\n/** WEBPACK FOOTER **\n ** bundle.2190dd243d3bc467abd9.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 2190dd243d3bc467abd9\n **/","\nimport 'skeleton-scss/scss/skeleton.scss';\nimport './style';\n\nrequire('isomorphic-fetch');\n\nwindow.SERVICE_URL = (ENV === 'development') ? 'http://localhost:8080' : '';\nif (ENV === 'production') {\n  require('offline-plugin/runtime').install();\n}\n\n// Require all tags\nconst req = require.context(\"./tags\", true, /\\.tag$/);\nreq.keys().forEach((key) => req(key));\n\nconst store = require('store');\nconst colorchart = require('colorchart')();\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  riot.mount('*', {\n    store: store, \n    colorchart: colorchart\n  });\n});\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","/* Riot v2.4.1, @license MIT */\n\n;(function(window, undefined) {\n  'use strict';\nvar riot = { version: 'v2.4.1', settings: {} },\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n\n  // counter to give a unique id to all the Tag instances\n  __uid = 0,\n  // tags instances cache\n  __virtualDom = [],\n  // tags implementation cache\n  __tagImpl = {},\n\n  /**\n   * Const\n   */\n  GLOBAL_MIXIN = '__global_mixin',\n\n  // riot specific prefixes\n  RIOT_PREFIX = 'riot-',\n  RIOT_TAG = RIOT_PREFIX + 'tag',\n  RIOT_TAG_IS = 'data-is',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n  // special native tags that cannot be treated like the others\n  SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n  RESERVED_WORDS_BLACKLIST = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|parent|opts|trigger|o(?:n|ff|ne))$/,\n  // SVG tags list https://www.w3.org/TR/SVG/attindex.html#PresentationAttributes\n  SVG_TAGS_LIST = ['altGlyph', 'animate', 'animateColor', 'circle', 'clipPath', 'defs', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feGaussianBlur', 'feImage', 'feMerge', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence', 'filter', 'font', 'foreignObject', 'g', 'glyph', 'glyphRef', 'image', 'line', 'linearGradient', 'marker', 'mask', 'missing-glyph', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'switch', 'symbol', 'text', 'textPath', 'tref', 'tspan', 'use'],\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (window && window.document || {}).documentMode | 0,\n\n  // detect firefox to fix #1374\n  FIREFOX = window && !!window.InstallTrigger\n/* istanbul ignore next */\nriot.observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice\n\n  /**\n   * Private Methods\n   */\n\n  /**\n   * Helper function needed to get and loop all the events in a string\n   * @param   { String }   e - event string\n   * @param   {Function}   fn - callback\n   */\n  function onEachEvent(e, fn) {\n    var es = e.split(' '), l = es.length, i = 0, name, indx\n    for (; i < l; i++) {\n      name = es[i]\n      indx = name.indexOf('.')\n      if (name) fn( ~indx ? name.substring(0, indx) : name, i, ~indx ? name.slice(indx + 1) : null)\n    }\n  }\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given space separated list of `events` and\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } events - events ids\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(events, fn) {\n        if (typeof fn != 'function')  return el\n\n        onEachEvent(events, function(name, pos, ns) {\n          (callbacks[name] = callbacks[name] || []).push(fn)\n          fn.typed = pos > 0\n          fn.ns = ns\n        })\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given space separated list of `events` listeners\n     * @param   { String } events - events ids\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(events, fn) {\n        if (events == '*' && !fn) callbacks = {}\n        else {\n          onEachEvent(events, function(name, pos, ns) {\n            if (fn || ns) {\n              var arr = callbacks[name]\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn || ns && cb.ns == ns) arr.splice(i--, 1)\n              }\n            } else delete callbacks[name]\n          })\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given space separated list of `events` and\n     * execute the `callback` at most once\n     * @param   { String } events - events ids\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(events, fn) {\n        function on() {\n          el.off(events, on)\n          fn.apply(el, arguments)\n        }\n        return el.on(events, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given space separated list of `events`\n     * @param   { String } events - events ids\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(events) {\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns\n\n        for (var i = 0; i < arglen; i++) {\n          args[i] = arguments[i + 1] // skip first argument\n        }\n\n        onEachEvent(events, function(name, pos, ns) {\n\n          fns = slice.call(callbacks[name] || [], 0)\n\n          for (var i = 0, fn; fn = fns[i]; ++i) {\n            if (fn.busy) continue\n            fn.busy = 1\n            if (!ns || fn.ns == ns) fn.apply(el, fn.typed ? [name].concat(args) : args)\n            if (fns[i] !== fn) { i-- }\n            fn.busy = 0\n          }\n\n          if (callbacks['*'] && name != '*')\n            el.trigger.apply(el, ['*', name].concat(args))\n\n        })\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  })\n\n  return el\n\n}\n/* istanbul ignore next */\n;(function(riot) {\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\n\nvar RE_ORIGIN = /^.+?\\/\\/+[^\\/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  REPLACE = 'replace',\n  POPSTATE = 'popstate',\n  HASHCHANGE = 'hashchange',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = typeof window != 'undefined' && window,\n  doc = typeof document != 'undefined' && document,\n  hist = win && history,\n  loc = win && (hist.location || win.location), // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  started = false,\n  central = riot.observable(),\n  routeFound = false,\n  debouncedEmit,\n  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n    args = path.match(re)\n\n  if (args) return args.slice(1)\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t\n  return function () {\n    clearTimeout(t)\n    t = setTimeout(fn, delay)\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1)\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n  doc[ADD_EVENT_LISTENER](clickEvent, click)\n  if (autoExec) emit(true)\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = []\n  riot.observable(this) // make it observable\n  central.on('stop', this.s.bind(this))\n  central.on('emit', this.e.bind(this))\n}\n\nfunction normalize(path) {\n  return path[REPLACE](/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] == '#'\n    ? (href || loc.href || '').split(base)[1] || ''\n    : (loc ? getPathFromRoot(href) : href || '')[REPLACE](base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel == 0\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\n  emitStackLevel++\n  emitStack.push(function() {\n    var path = getPathFromBase()\n    if (force || path != current) {\n      central[TRIGGER]('emit', path)\n      current = path\n    }\n  })\n  if (isRoot) {\n    while (emitStack.length) {\n      emitStack[0]()\n      emitStack.shift()\n    }\n    emitStackLevel = 0\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which != 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) return\n\n  var el = e.target\n  while (el && el.nodeName != 'A') el = el.parentNode\n\n  if (\n    !el || el.nodeName != 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target != '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n  ) return\n\n  if (el.href != loc.href) {\n    if (\n      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    ) return\n  }\n\n  e.preventDefault()\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @param {boolean} shouldReplace - use replaceState or pushState\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title, shouldReplace) {\n  if (hist) { // if a browser\n    path = base + normalize(path)\n    title = title || doc.title\n    // browsers ignores the second parameter `title`\n    shouldReplace\n      ? hist.replaceState(null, title, path)\n      : hist.pushState(null, title, path)\n    // so we need to set it manually\n    doc.title = title\n    routeFound = false\n    emit()\n    return routeFound\n  }\n\n  // Server-side usage: directly execute handlers for the path\n  return central[TRIGGER]('emit', getPathFromBase(path))\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * two strings and boolean:        replace history with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n * @param {boolean} third - replace flag\n */\nprot.m = function(first, second, third) {\n  if (isString(first) && (!second || isString(second))) go(first, second, third || false)\n  else if (second) this.r(first, second)\n  else this.r('@', first)\n}\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*')\n  this.$ = []\n}\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args))\n      return routeFound = true // exit from loop\n    }\n  }, this)\n}\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter != '@') {\n    filter = '/' + normalize(filter)\n    this.$.push(filter)\n  }\n  this.on(filter, action)\n}\n\nvar mainRouter = new Router()\nvar route = mainRouter.m.bind(mainRouter)\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router()\n  // assign sub-router's main method\n  var router = newSubRouter.m.bind(newSubRouter)\n  // stop only this sub-router\n  router.stop = newSubRouter.s.bind(newSubRouter)\n  return router\n}\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#'\n  current = getPathFromBase() // recalculate current path\n}\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true)\n}\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER\n    secondParser = DEFAULT_SECOND_PARSER\n  }\n  if (fn) parser = fn\n  if (fn2) secondParser = fn2\n}\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {}\n  var href = loc.href || current\n  href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n  return q\n}\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    if (win) {\n      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n      doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n    }\n    central[TRIGGER]('stop')\n    started = false\n  }\n}\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (win) {\n      if (document.readyState == 'complete') start(autoExec)\n      // the timeout is needed to solve\n      // a weird safari bug https://github.com/riot/route/issues/33\n      else win[ADD_EVENT_LISTENER]('load', function() {\n        setTimeout(function() { start(autoExec) }, 1)\n      })\n    }\n    started = true\n  }\n}\n\n/** Prepare the router **/\nroute.base()\nroute.parser()\n\nriot.route = route\n})(riot)\n/* istanbul ignore next */\n\n/**\n * The riot template engine\n * @version v2.4.0\n */\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n    },\n\n    DEFAULT = '{ }'\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ]\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) bp = _cache\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) return _pairs\n\n    var arr = pair.split(' ')\n\n    if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) { // eslint-disable-line\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr)\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr)\n    arr[6] = _rewrite(_pairs[6], arr)\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB)\n    arr[8] = pair\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) _bp = _cache\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6]\n\n    isexpr = start = re.lastIndex = 0\n\n    while ((match = re.exec(str))) {\n\n      pos = match.index\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(str, match[2], re.lastIndex)\n          continue\n        }\n        if (!match[3]) {\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos))\n        start = re.lastIndex\n        re = _bp[6 + (isexpr ^= 1)]\n        re.lastIndex = start\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start))\n    }\n\n    return parts\n\n    function unescapeStr (s) {\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'))\n      } else {\n        parts.push(s)\n      }\n    }\n\n    function skipBraces (s, ch, ix) {\n      var\n        match,\n        recch = FINDBRACES[ch]\n\n      recch.lastIndex = ix\n      ix = 1\n      while ((match = recch.exec(s))) {\n        if (match[1] &&\n          !(match[1] === ch ? ++ix : --ix)) break\n      }\n      return ix ? s.length : recch.lastIndex\n    }\n  }\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  }\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9])\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  }\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  }\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair)\n      _regex = pair === DEFAULT ? _loopback : _rewrite\n      _cache[9] = _regex(_pairs[9])\n    }\n    cachedBrackets = pair\n  }\n\n  function _setSettings (o) {\n    var b\n\n    o = o || {}\n    b = o.brackets\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    })\n    _settings = o\n    _reset(b)\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  })\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n  _brackets.set = _reset\n\n  _brackets.R_STRINGS = R_STRINGS\n  _brackets.R_MLCOMMS = R_MLCOMMS\n  _brackets.S_QBLOCKS = S_QBLOCKS\n\n  return _brackets\n\n})()\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {}\n\n  function _tmpl (str, data) {\n    if (!str) return str\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.haveRaw = brackets.hasRaw\n\n  _tmpl.hasExpr = brackets.hasExpr\n\n  _tmpl.loopKeys = brackets.loopKeys\n\n  _tmpl.errorHandler = null\n\n  function _logErr (err, ctx) {\n\n    if (_tmpl.errorHandler) {\n\n      err.riotData = {\n        tagName: ctx && ctx.root && ctx.root.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      }\n      _tmpl.errorHandler(err)\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str)\n\n    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\n/* eslint-disable */\n\n    return new Function('E', expr + ';')\n/* eslint-enable */\n  }\n\n  var\n    CH_IDEXPR = '\\u2057',\n    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_DQUOTE = /\\u2057/g,\n    RE_QBMARK = /\\u2057(\\d+)~/g\n\n  function _getTmpl (str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1)\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = []\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i]\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) list[j++] = expr\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")'\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr)\n    }\n\n    if (qstr[0]) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      })\n    }\n    return expr\n  }\n\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    }\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g\n\n        expr = RegExp.rightContext\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\n        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\n        jsb  = expr.slice(0, match.index)\n        expr = RegExp.rightContext\n\n        list[cnt++] = _wrapExpr(jsb, 1, key)\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch]\n\n      ir.lastIndex = re.lastIndex\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) ++lv\n        else if (!--lv) break\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/\n\n  function _wrapExpr (expr, asText, key) {\n    var tb\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos))\n        }\n      }\n      return match\n    })\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"'\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)'\n    }\n\n    return expr\n  }\n\n  // istanbul ignore next: compatibility fix for beta versions\n  _tmpl.parse = function (s) { return s }\n\n  _tmpl.version = brackets.version = 'v2.4.0'\n\n  return _tmpl\n\n})()\n\n/*\n  lib/browser/tag/mkdom.js\n\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\nvar mkdom = (function _mkdom() {\n  var\n    reHasYield  = /<yield\\b/i,\n    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n    reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig\n  var\n    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n    tblTags = IE_VERSION && IE_VERSION < 10\n      ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/\n\n  /**\n   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n   *\n   * @param   {string} templ  - The template coming from the custom tag definition\n   * @param   {string} [html] - HTML content that comes from the DOM element where you\n   *           will mount the tag, mostly the original tag in the page\n   * @returns {HTMLElement} DOM element with _templ_ merged through `YIELD` with the _html_.\n   */\n  function _mkdom(templ, html) {\n    var\n      match   = templ && templ.match(/^\\s*<([-\\w]+)/),\n      tagName = match && match[1].toLowerCase(),\n      el = mkEl('div', isSVGTag(tagName))\n\n    // replace all the yield tags with the tag inner html\n    templ = replaceYield(templ, html)\n\n    /* istanbul ignore next */\n    if (tblTags.test(tagName))\n      el = specialTags(el, templ, tagName)\n    else\n      setInnerHTML(el, templ)\n\n    el.stub = true\n\n    return el\n  }\n\n  /*\n    Creates the root element for table or select child elements:\n    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n  */\n  function specialTags(el, templ, tagName) {\n    var\n      select = tagName[0] === 'o',\n      parent = select ? 'select>' : 'table>'\n\n    // trim() is important here, this ensures we don't have artifacts,\n    // so we can check if we have only one element inside the parent\n    el.innerHTML = '<' + parent + templ.trim() + '</' + parent\n    parent = el.firstChild\n\n    // returns the immediate parent if tr/th/td/col is the only element, if not\n    // returns the whole tree, as this can include additional elements\n    if (select) {\n      parent.selectedIndex = -1  // for IE9, compatible w/current riot behavior\n    } else {\n      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n      var tname = rootEls[tagName]\n      if (tname && parent.childElementCount === 1) parent = $(tname, parent)\n    }\n    return parent\n  }\n\n  /*\n    Replace the yield tag from any tag template with the innerHTML of the\n    original tag in the page\n  */\n  function replaceYield(templ, html) {\n    // do nothing if no yield\n    if (!reHasYield.test(templ)) return templ\n\n    // be careful with #1343 - string on the source having `$1`\n    var src = {}\n\n    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n      src[ref] = src[ref] || text   // preserve first definition\n      return ''\n    }).trim()\n\n    return templ\n      .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n        return src[ref] || def || ''\n      })\n      .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n        return html || def || ''\n      })\n  }\n\n  return _mkdom\n\n})()\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n\n  var i = tags.length,\n    j = items.length,\n    t\n\n  while (i > j) {\n    t = tags[--i]\n    tags.splice(i, 1)\n    t.unmount()\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @param   { Object } child - non custom loop tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(child, i) {\n  Object.keys(child.tags).forEach(function(tagName) {\n    var tag = child.tags[tagName]\n    if (isArray(tag))\n      each(tag, function (t) {\n        moveChildTag(t, tagName, i)\n      })\n    else\n      moveChildTag(tag, tagName, i)\n  })\n}\n\n/**\n * Adds the elements for a virtual tag\n * @param { Tag } tag - the tag whose root's children will be inserted or appended\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction addVirtual(tag, src, target) {\n  var el = tag._root, sib\n  tag._virts = []\n  while (el) {\n    sib = el.nextSibling\n    if (target)\n      src.insertBefore(el, target._root)\n    else\n      src.appendChild(el)\n\n    tag._virts.push(el) // hold for unmounting\n    el = sib\n  }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @param { Tag } tag - first child reference used to start move\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n * @param { Number } len - how many child nodes to move\n */\nfunction moveVirtual(tag, src, target, len) {\n  var el = tag._root, sib, i = 0\n  for (; i < len; i++) {\n    sib = el.nextSibling\n    src.insertBefore(el, target._root)\n    el = sib\n  }\n}\n\n\n/**\n * Manage tags having the 'each'\n * @param   { Object } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each')\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __tagImpl[tagName] || { tmpl: getOuterHTML(dom) },\n    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n    root = dom.parentNode,\n    ref = document.createTextNode(''),\n    child = getTag(dom),\n    isOption = tagName.toLowerCase() === 'option', // the option tags must be treated differently\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isVirtual = dom.tagName == 'VIRTUAL'\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr)\n\n  // insert a marked where the loop tags will be injected\n  root.insertBefore(ref, dom)\n\n  // clean template code\n  parent.one('before-mount', function () {\n\n    // remove the original DOM node\n    dom.parentNode.removeChild(dom)\n    if (root.stub) root = parent.root\n\n  }).on('update', function () {\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      // create a fragment to hold the new DOM nodes to inject in the parent tag\n      frag = document.createDocumentFragment()\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      hasKeys = items || false\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, key, items[key])\n        }) : []\n    }\n\n    // loop all the new items\n    var i = 0,\n      itemsLength = items.length\n\n    for (; i < itemsLength; i++) {\n      // reorder only if the items are objects\n      var\n        item = items[i],\n        _mustReorder = mustReorder && typeof item == T_OBJECT && !hasKeys,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos]\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n      ) {\n\n        tag = new Tag(impl, {\n          parent: parent,\n          isLoop: true,\n          hasImpl: !!__tagImpl[tagName],\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML)\n\n        tag.mount()\n\n        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n        // this tag must be appended\n        if (i == tags.length || !tags[i]) { // fix 1581\n          if (isVirtual)\n            addVirtual(tag, frag)\n          else frag.appendChild(tag.root)\n        }\n        // this tag must be insert\n        else {\n          if (isVirtual)\n            addVirtual(tag, root, tags[i])\n          else root.insertBefore(tag.root, tags[i].root) // #1374 some browsers reset selected here\n          oldItems.splice(i, 0, item)\n        }\n\n        tags.splice(i, 0, tag)\n        pos = i // handled here so no move\n      } else tag.update(item, true)\n\n      // reorder the tag if it's not located in its previous position\n      if (\n        pos !== i && _mustReorder &&\n        tags[i] // fix 1581 unable to reproduce it in a test!\n      ) {\n        // update the DOM\n        if (isVirtual)\n          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n        else root.insertBefore(tag.root, tags[i].root)\n        // update the position attribute if it exists\n        if (expr.pos)\n          tag[expr.pos] = i\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0])\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) moveNestedTags(tag, i)\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent)\n    }\n\n    // remove the redundant tags\n    unmountRedundant(items, tags)\n\n    // insert the new nodes\n    if (isOption) {\n      root.appendChild(frag)\n\n      // #1374 FireFox bug in <option selected={expression}>\n      if (FIREFOX && !root.multiple) {\n        for (var n = 0; n < root.length; n++) {\n          if (root[n].__riot1374) {\n            root.selectedIndex = n  // clear other options\n            delete root[n].__riot1374\n            break\n          }\n        }\n      }\n    }\n    else root.insertBefore(frag, ref)\n\n    // set the 'tags' property of the parent tag\n    // if child is 'undefined' it means that we don't need to set this property\n    // for example:\n    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n    if (child) parent.tags[tagName] = tags\n\n    // clone the items array\n    oldItems = items.slice()\n\n  })\n\n}\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = (function(_riot) {\n\n  if (!window) return { // skip injection on the server\n    add: function () {},\n    inject: function () {}\n  }\n\n  var styleNode = (function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style')\n    setAttr(newNode, 'type', 'text/css')\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]')\n    if (userNode) {\n      if (userNode.id) newNode.id = userNode.id\n      userNode.parentNode.replaceChild(newNode, userNode)\n    }\n    else document.getElementsByTagName('head')[0].appendChild(newNode)\n\n    return newNode\n  })()\n\n  // Create cache and shortcut to the correct property\n  var cssTextProp = styleNode.styleSheet,\n    stylesToInject = ''\n\n  // Expose the style node in a non-modificable property\n  Object.defineProperty(_riot, 'styleNode', {\n    value: styleNode,\n    writable: true\n  })\n\n  /**\n   * Public api\n   */\n  return {\n    /**\n     * Save a tag style to be later injected into DOM\n     * @param   { String } css [description]\n     */\n    add: function(css) {\n      stylesToInject += css\n    },\n    /**\n     * Inject all previously saved tag styles into DOM\n     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n     */\n    inject: function() {\n      if (stylesToInject) {\n        if (cssTextProp) cssTextProp.cssText += stylesToInject\n        else styleNode.innerHTML += stylesToInject\n        stylesToInject = ''\n      }\n    }\n  }\n\n})(riot)\n\n\nfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop ||\n                  (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each'))\n                    ? 1 : 0\n\n      // custom child tag\n      if (childTags) {\n        var child = getTag(dom)\n\n        if (child && !dom.isLoop)\n          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n      }\n\n      if (!dom.isLoop || forceParsingNamed)\n        setNamed(dom, tag, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (tmpl.hasExpr(val)) {\n      expressions.push(extend({ dom: dom, expr: val }, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType,\n      attr\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    attr = getAttr(dom, 'each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n    opts = inherit(conf.opts) || {},\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    hasImpl = conf.hasImpl,\n    item = cleanUpData(conf.item),\n    expressions = [],\n    childTags = [],\n    root = conf.root,\n    tagName = root.tagName.toLowerCase(),\n    attr = {},\n    propsInSyncWithParent = [],\n    dom\n\n  // only call unmount if we have a valid __tagImpl (has name property)\n  if (impl.name && root._tag) root._tag.unmount(true)\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\n  extend(this, { parent: parent, root: root, opts: opts}, item)\n  // protect the \"tags\" property from being overridden\n  defineProperty(this, 'tags', {})\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (tmpl.hasExpr(val)) attr[el.name] = val\n  })\n\n  dom = mkdom(impl.tmpl, innerHTML)\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      var val = el.value\n      opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[toCamel(name)] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFromParent () {\n    if (!self.parent || !isLoop) return\n    each(Object.keys(self.parent), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !RESERVED_WORDS_BLACKLIST.test(k) && contains(propsInSyncWithParent, k)\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = self.parent[k]\n      }\n    })\n  }\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @param   { Boolean } isInherited - is this update coming from a parent tag?\n   * @returns { self }\n   */\n  defineProperty(this, 'update', function(data, isInherited) {\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent\n    inheritFromParent()\n    // normalize the tag properties in case an item object was initially passed\n    if (data && isObject(item)) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n\n    // the updated event will be triggered\n    // once the DOM will be ready and all the re-flows are completed\n    // this is useful if you want to get the \"real\" root properties\n    // 4 ex: root.offsetWidth ...\n    if (isInherited && self.parent)\n      // closes #1599\n      self.parent.one('updated', function() { self.trigger('updated') })\n    else rAF(function() { self.trigger('updated') })\n\n    return this\n  })\n\n  defineProperty(this, 'mixin', function() {\n    each(arguments, function(mix) {\n      var instance\n\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix()\n        // save the prototype to loop it afterwards\n        mix = mix.prototype\n      } else instance = mix\n\n      // loop the keys in the function prototype or the all object keys\n      each(Object.getOwnPropertyNames(mix), function(key) {\n        // bind methods to self\n        if (key != 'init')\n          self[key] = isFunction(instance[key]) ?\n                        instance[key].bind(self) :\n                        instance[key]\n      })\n\n      // init method will be called automatically\n      if (instance.init) instance.init.bind(self)()\n    })\n    return this\n  })\n\n  defineProperty(this, 'mount', function() {\n\n    updateOpts()\n\n    // add global mixins\n    var globalMixin = riot.mixin(GLOBAL_MIXIN)\n    if (globalMixin)\n      for (var i in globalMixin)\n        if (globalMixin.hasOwnProperty(i))\n          self.mixin(globalMixin[i])\n\n    // initialiation\n    if (impl.fn) impl.fn.call(self, opts)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    // mount the child tags\n    toggle(true)\n\n    // update the root adding custom attributes coming from the compiler\n    // it fixes also #1087\n    if (impl.attrs)\n      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n    if (impl.attrs || hasImpl)\n      parseExpressions(self.root, self, expressions)\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('before-mount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      root = dom.firstChild\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) root = parent.root\n    }\n\n    defineProperty(self, 'root', root)\n\n    // parse the named dom nodes in the looped child\n    // adding them to the parent as well\n    if (isLoop)\n      parseNamedElements(self.root, self.parent, null, true)\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  })\n\n\n  defineProperty(this, 'unmount', function(keepRootTag) {\n    var el = root,\n      p = el.parentNode,\n      ptag,\n      tagIndex = __virtualDom.indexOf(self)\n\n    self.trigger('before-unmount')\n\n    // remove this tag instance from the global virtualDom variable\n    if (~tagIndex)\n      __virtualDom.splice(tagIndex, 1)\n\n    if (p) {\n\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(ptag.tags[tagName]))\n          each(ptag.tags[tagName], function(tag, i) {\n            if (tag._riot_id == self._riot_id)\n              ptag.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          ptag.tags[tagName] = undefined\n      }\n\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n      else {\n        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n        remAttr(p, RIOT_TAG_IS)\n        remAttr(p, RIOT_TAG) // this will be removed in riot 3.0.0\n      }\n\n    }\n\n    if (this._virts) {\n      each(this._virts, function(v) {\n        if (v.parentNode) v.parentNode.removeChild(v)\n      })\n    }\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    self.isMounted = false\n    delete root._tag\n\n  })\n\n  // proxy function to bind updates\n  // dispatched from a parent tag\n  function onChildUpdate(data) { self.update(data, true) }\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (!parent) return\n    var evt = isMount ? 'on' : 'off'\n\n    // the loop tags will be always in sync with the parent automatically\n    if (isLoop)\n      parent[evt]('unmount', self.unmount)\n    else {\n      parent[evt]('update', onChildUpdate)[evt]('unmount', self.unmount)\n    }\n  }\n\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n}\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var ptag = tag._parent,\n      item = tag._item,\n      el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag._parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // override the event properties\n    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n    if (isWritable(e, 'target')) e.target = e.srcElement\n    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n\n  }\n\n}\n\n\n/**\n * Insert a DOM node replacing another one (used by if- attribute)\n * @param   { Object } root - parent node\n * @param   { Object } node - node replaced\n * @param   { Object } before - node added\n */\nfunction insertTo(root, node, before) {\n  if (!root) return\n  root.insertBefore(before, node)\n  root.removeChild(node)\n}\n\n/**\n * Update the expressions in a Tag instance\n * @param   { Array } expressions - expression that must be re evaluated\n * @param   { Tag } tag - tag instance\n */\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n      attrName = expr.attr,\n      value = tmpl(expr.expr, tag),\n      parent = expr.dom.parentNode\n\n    if (expr.bool) {\n      value = !!value\n    } else if (value == null) {\n      value = ''\n    }\n\n    // #1638: regression of #1612, update the dom only if the value of the\n    // expression was changed\n    if (expr.value === value) {\n      return\n    }\n    expr.value = value\n\n    // textarea and text nodes has no attribute name\n    if (!attrName) {\n      // about #815 w/o replace: the browser converts the value to a string,\n      // the comparison by \"==\" does too, but not in the server\n      value += ''\n      // test for parent avoids error with invalid assignment to nodeValue\n      if (parent) {\n        if (parent.tagName === 'TEXTAREA') {\n          parent.value = value                    // #1113\n          if (!IE_VERSION) dom.nodeValue = value  // #1625 IE throws here, nodeValue\n        }                                         // will be available on 'updated'\n        else dom.nodeValue = value\n      }\n      return\n    }\n\n    // ~~#1612: look for changes in dom.value when updating the value~~\n    if (attrName === 'value') {\n      dom.value = value\n      return\n    }\n\n    // remove original attribute\n    remAttr(dom, attrName)\n\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub,\n        add = function() { insertTo(stub.parentNode, stub, dom) },\n        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          add()\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted)\n                el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        // if the parentNode is defined we can easily replace the tag\n        if (dom.parentNode)\n          remove()\n        // otherwise we need to wait the updated event\n        else (tag.parent || tag).one('updated', remove)\n\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (attrName === 'show') {\n      dom.style.display = value ? '' : 'none'\n\n    } else if (attrName === 'hide') {\n      dom.style.display = value ? 'none' : ''\n\n    } else if (expr.bool) {\n      dom[attrName] = value\n      if (value) setAttr(dom, attrName, attrName)\n      if (FIREFOX && attrName === 'selected' && dom.tagName === 'OPTION') {\n        dom.__riot1374 = value   // #1374\n      }\n\n    } else if (value === 0 || value && typeof value !== T_OBJECT) {\n      // <img src=\"{ expr }\">\n      if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n        attrName = attrName.slice(RIOT_PREFIX.length)\n      }\n      setAttr(dom, attrName, value)\n    }\n\n  })\n\n}\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } els - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(els, fn) {\n  var len = els ? els.length : 0\n\n  for (var i = 0, el; i < len; i++) {\n    el = els[i]\n    // return false -> current item was removed by fn during the loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\n/**\n * Detect if the argument passed is a function\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isFunction(v) {\n  return typeof v === T_FUNCTION || false   // avoid IE problems\n}\n\n/**\n * Get the outer html of any DOM node SVGs included\n * @param   { Object } el - DOM node to parse\n * @returns { String } el.outerHTML\n */\nfunction getOuterHTML(el) {\n  if (el.outerHTML) return el.outerHTML\n  // some browsers do not support outerHTML on the SVGs tags\n  else {\n    var container = mkEl('div')\n    container.appendChild(el.cloneNode(true))\n    return container.innerHTML\n  }\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we will inject the new html\n * @param { String } html - html to inject\n */\nfunction setInnerHTML(container, html) {\n  if (typeof container.innerHTML != T_UNDEF) container.innerHTML = html\n  // some browsers do not support innerHTML on the SVGs tags\n  else {\n    var doc = new DOMParser().parseFromString(html, 'application/xml')\n    container.appendChild(\n      container.ownerDocument.importNode(doc.documentElement, true)\n    )\n  }\n}\n\n/**\n * Checks wether a DOM node must be considered part of an svg document\n * @param   { String }  name - tag name\n * @returns { Boolean } -\n */\nfunction isSVGTag(name) {\n  return ~SVG_TAGS_LIST.indexOf(name)\n}\n\n/**\n * Detect if the argument passed is an object, exclude null.\n * NOTE: Use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isObject(v) {\n  return v && typeof v === T_OBJECT         // typeof null is 'object'\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } string - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(string) {\n  return string.replace(/-(\\w)/g, function(_, c) {\n    return c.toUpperCase()\n  })\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  dom.setAttribute(name, val)\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG_IS) ||\n    getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n}\n/**\n * Add a child tag to its parent into the `tags` object\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the new tag will be stored\n * @param   { Object } parent - tag instance where the new child tag will be included\n */\nfunction addChildTag(tag, tagName, parent) {\n  var cachedTag = parent.tags[tagName]\n\n  // if there are multiple children tags having the same name\n  if (cachedTag) {\n    // if the parent tags property is not yet an array\n    // create it adding the first cached tag\n    if (!isArray(cachedTag))\n      // don't add the same tag twice\n      if (cachedTag !== tag)\n        parent.tags[tagName] = [cachedTag]\n    // add the new nested tag to the array\n    if (!contains(parent.tags[tagName], tag))\n      parent.tags[tagName].push(tag)\n  } else {\n    parent.tags[tagName] = tag\n  }\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tag, tagName, newPos) {\n  var parent = tag.parent,\n    tags\n  // no parent no move\n  if (!parent) return\n\n  tags = parent.tags[tagName]\n\n  if (isArray(tags))\n    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n  else addChildTag(tag, tagName, parent)\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag(child, opts, innerHTML),\n    tagName = getTagName(opts.root),\n    ptag = getImmediateCustomParentTag(parent)\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent\n\n  // add this tag to the custom parent tag\n  addChildTag(tag, tagName, ptag)\n  // and also to the real parent tag\n  if (ptag !== parent)\n    addChildTag(tag, tagName, parent)\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = ''\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag\n  while (!getTag(ptag.root)) {\n    if (!ptag.parent) break\n    ptag = ptag.parent\n  }\n  return ptag\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n* @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options))\n  return el\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = getAttr(dom, 'name'),\n    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } arr - target array\n * @param   { * } item - item to test\n * @returns { Boolean } Does 'arr' contain 'item'?\n */\nfunction contains(arr, item) {\n  return ~arr.indexOf(item)\n}\n\n/**\n * Check whether an object is a kind of array\n * @param   { * } a - anything\n * @returns {Boolean} is 'a' an array?\n */\nfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\n/**\n * Detect whether a property of an object could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } is this property writable?\n */\nfunction isWritable(obj, key) {\n  var props = Object.getOwnPropertyDescriptor(obj, key)\n  return typeof obj[key] === T_UNDEF || props && props.writable\n}\n\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))\n    return data\n\n  var o = {}\n  for (var key in data) {\n    if (!RESERVED_WORDS_BLACKLIST.test(key)) o[key] = data[key]\n  }\n  return o\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n */\nfunction walk(dom, fn) {\n  if (dom) {\n    // stop the recursion\n    if (fn(dom) === false) return\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  var m,\n    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\n  while (m = re.exec(html)) {\n    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n  }\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @param   { Boolean } isSvg - should we use a SVG as parent node?\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name, isSvg) {\n  return isSvg ?\n    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n    document.createElement(name)\n}\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Simple object prototypal inheritance\n * @param   { Object } parent - parent object\n * @returns { Object } child instance\n */\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\n/**\n * Get the name property needed to identify a DOM node in riot\n * @param   { Object } dom - DOM node we need to parse\n * @returns { String | undefined } give us back a string to identify this dom node\n */\nfunction getNamedKey(dom) {\n  return getAttr(dom, 'id') || getAttr(dom, 'name')\n}\n\n/**\n * Set the named properties of a tag element\n * @param { Object } dom - DOM node we need to parse\n * @param { Object } parent - tag instance where the named dom element will be eventually added\n * @param { Array } keys - list of all the tag instance properties\n */\nfunction setNamed(dom, parent, keys) {\n  // get the key value we want to add to the tag instance\n  var key = getNamedKey(dom),\n    isArr,\n    // add the node detected to a tag instance using the named property\n    add = function(value) {\n      // avoid to override the tag properties already set\n      if (contains(keys, key)) return\n      // check whether this value is an array\n      isArr = isArray(value)\n      // if the key was never set\n      if (!value)\n        // set it once on the tag instance\n        parent[key] = dom\n      // if it was an array and not yet set\n      else if (!isArr || isArr && !contains(value, dom)) {\n        // add the dom node into the array\n        if (isArr)\n          value.push(dom)\n        else\n          parent[key] = [value, dom]\n      }\n    }\n\n  // skip the elements with no named properties\n  if (!key) return\n\n  // check whether this key has been already evaluated\n  if (tmpl.hasExpr(key))\n    // wait the first updated event only once\n    parent.one('mount', function() {\n      key = getNamedKey(dom)\n      add(parent[key])\n    })\n  else\n    add(parent[key])\n\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } src - source string\n * @param   { String } str - test string\n * @returns { Boolean } -\n */\nfunction startsWith(src, str) {\n  return src.slice(0, str.length) === str\n}\n\n/**\n * requestAnimationFrame function\n * Adapted from https://gist.github.com/paulirish/1579671, license MIT\n */\nvar rAF = (function (w) {\n  var raf = w.requestAnimationFrame    ||\n            w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame\n\n  if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {  // buggy iOS6\n    var lastTime = 0\n\n    raf = function (cb) {\n      var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0)\n      setTimeout(function () { cb(lastTime = nowtime + timeout) }, timeout)\n    }\n  }\n  return raf\n\n})(window || {})\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts) {\n  var tag = __tagImpl[tagName],\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    // add this tag to the virtualDom variable\n    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n  }\n\n  return tag\n}\n/**\n * Riot public api\n */\n\n// share methods for other riot parts, e.g. compiler\nriot.util = { brackets: brackets, tmpl: tmpl }\n\n/**\n * Create a mixin that could be globally shared across all the tags\n */\nriot.mixin = (function() {\n  var mixins = {},\n    globals = mixins[GLOBAL_MIXIN] = {},\n    _id = 0\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String }  name - mixin name (global mixin if object)\n   * @param   { Object }  mixin - mixin logic\n   * @param   { Boolean } g - is global?\n   * @returns { Object }  the mixin logic\n   */\n  return function(name, mixin, g) {\n    // Unnamed global\n    if (isObject(name)) {\n      riot.mixin('__unnamed_'+_id++, name, true)\n      return\n    }\n\n    var store = g ? globals : mixins\n\n    // Getter\n    if (!mixin) {\n      if (typeof store[name] === T_UNDEF) {\n        throw new Error('Unregistered mixin: ' + name)\n      }\n      return store[name]\n    }\n    // Setter\n    if (isFunction(mixin)) {\n      extend(mixin.prototype, store[name] || {})\n      store[name] = mixin\n    }\n    else {\n      store[name] = extend(store[name] || {}, mixin)\n    }\n  }\n\n})()\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else styleManager.add(css)\n  }\n  name = name.toLowerCase()\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag2 = function(name, html, css, attrs, fn) {\n  if (css) styleManager.add(css)\n  //if (bpair) riot.settings.brackets = bpair\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { String } selector - tag DOM selector\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n    allTags,\n    tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      if (!/[^-\\w]/.test(e)) {\n        e = e.trim().toLowerCase()\n        list += ',[' + RIOT_TAG_IS + '=\"' + e + '\"],[' + RIOT_TAG + '=\"' + e + '\"]'\n      }\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(__tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, RIOT_TAG_IS) || getAttr(root, RIOT_TAG)\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName\n        setAttr(root, RIOT_TAG_IS, tagName)\n        setAttr(root, RIOT_TAG, tagName) // this will be removed in riot 3.0.0\n      }\n      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    } else if (root.length) {\n      each(root, pushTags)   // assume nodeList\n    }\n  }\n\n  // ----- mount code -----\n\n  // inject styles into DOM\n  styleManager.inject()\n\n  if (isObject(tagName)) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(/, */))\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    els = selector ? $$(selector) : []\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  pushTags(els)\n\n  return tags\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nriot.update = function() {\n  return each(__virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n/**\n * Export the Virtual DOM\n */\nriot.vdom = __virtualDom\n\n/**\n * Export the Tag constructor\n */\nriot.Tag = Tag\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (typeof define === T_FUNCTION && typeof define.amd !== T_UNDEF)\n    define(function() { return riot })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : void 0);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/riot/riot.js\n ** module id = 1\n ** module chunks = 0\n **/","var getPrototype = require('./_getPrototype'),\n    isHostObject = require('./_isHostObject'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object,\n *  else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) ||\n      objectToString.call(value) != objectTag || isHostObject(value)) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nmodule.exports = isPlainObject;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/lodash/isPlainObject.js\n ** module id = 2\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = compose;\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  } else {\n    var _ret = function () {\n      var last = funcs[funcs.length - 1];\n      var rest = funcs.slice(0, -1);\n      return {\n        v: function v() {\n          return rest.reduceRight(function (composed, f) {\n            return f(composed);\n          }, last.apply(undefined, arguments));\n        }\n      };\n    }();\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/redux/lib/compose.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports.ActionTypes = undefined;\nexports[\"default\"] = createStore;\n\nvar _isPlainObject = require('lodash/isPlainObject');\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _symbolObservable = require('symbol-observable');\n\nvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = exports.ActionTypes = {\n  INIT: '@@redux/INIT'\n};\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [initialState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} enhancer The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nfunction createStore(reducer, initialState, enhancer) {\n  var _ref2;\n\n  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = initialState;\n    initialState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, initialState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = initialState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected listener to be a function.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!(0, _isPlainObject2[\"default\"])(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i]();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/zenparsing/es-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[_symbolObservable2[\"default\"]] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[_symbolObservable2[\"default\"]] = observable, _ref2;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/redux/lib/createStore.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = warning;\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/redux/lib/utils/warning.js\n ** module id = 5\n ** module chunks = 0\n **/","var riot = require(\"riot\");\n\nriot.tag2('app', '<header category=\"{state.category}\"></header> <div class=\"wrapper\" onclick=\"{close}\"> <section class=\"{focus: selected}\"> <h3 if=\"{!state.items.hasError && !state.items.isFetching}\">{state.title}</h3> <h3 class=\"message-status\" if=\"{state.items.hasError}\">Sorry, something went wrong.</h3> <h3 class=\"message-status\" if=\"{state.items.isFetching}\"><p class=\"loading\"><span>.</span><span>.</span><span>.</span></p></h3> <ul> <li each=\"{this.state.items.data}\" no-reorder> <item data=\"{this}\"></item> </li> </ul> </section> </div> <footer></footer>', '', '', function(opts) {\n\n  const store = opts.store;\n\n  this.state = store.getState();\n\n  store.subscribe(() => {\n    this.state = store.getState();\n    this.update();\n  });\n\n  this.fetchCategory = (category) => {\n    store.dispatch({type: 'FETCH_INIT'});\n    fetch(SERVICE_URL + '/feed/' + category)\n      .then((response) => response.json())\n      .then((data) => store.dispatch({type: 'FETCH_SUCCESS', data: data}))\n      .catch((e) => store.dispatch({type: 'FETCH_ERROR', data: e}))\n  }\n\n  riot.route('/top/*', (category) => {\n    store.dispatch({type: 'UPDATE_CATEGORY', data: category});\n    this.fetchCategory(category);\n    this.close();\n  });\n  riot.route.base('/');\n  riot.route.start();\n\n  this.open = function(item) {\n    const state = item.opened;\n    this.tags.item.forEach((i) => i.opened = false);\n    item.opened = !state;\n    this.selected = (item && item.opened) || null\n\n    const colorsmap = this.opts.colorchart.get(item.root.querySelector('img'), 2, 10);\n    var desc = item.root.querySelector('.description');\n    document.body.style.backgroundColor = 'rgb(' + colorsmap[0].join(',') + ')';\n    desc.style.color = 'rgb(' + colorsmap[1].join(',') + ')';\n  }\n\n  this.close = function(e) {\n    if (e && e.target.href) {\n      return true;\n    }\n    this.tags.item && this.tags.item.forEach((i) => i.opened = false);\n    this.selected = false;\n    document.body.style.backgroundColor = ''\n  }\n\n});\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./tags/app.tag\n **/","var riot = require(\"riot\");\n\n\nriot.tag2('footer', '<div class=\"align-middle\"> <div>A <a href=\"http://riotjs.com/\" target=\"_blank\">RiotJs</a> Experiment</div> <a href=\"https://github.com/JoTrdl/netflix-top\" target=\"_blank\"><div class=\"github\"></div></a> </div>', '', '', function(opts) {\n});\n\n\n/** WEBPACK FOOTER **\n ** ./tags/footer.tag\n **/","var riot = require(\"riot\");\n\nriot.tag2('category', '<select onchange=\"{change}\"> <option each=\"{value, text in options}\" value=\"{value}\" __selected=\"{value==selected}\">{text}</option> </select>', '', '', function(opts) {\n\n  this.selected = opts.category;\n\n  this.options = {\n    '100': 'Top 100',\n    new: 'New Releases',\n    action: 'Action & Adventure',\n    anime: 'Anime & Animation',\n    children: 'Children & Family',\n    classic: 'Classics',\n    comedy: 'Comedy',\n    documentary: 'Documentary',\n    drama: 'Drama',\n    faith: 'Faith & Spirituality',\n    foreign: 'Foreign',\n    gay: 'Gay & Lesbian',\n    horror: 'Horror',\n    independent: 'Independent',\n    music: 'Music & Musicals',\n    romance: 'Romance',\n    fantasy: 'Sci-Fi & Fantasy',\n    special: 'Special Interest',\n    sports: 'Sports & Fitness',\n    shows: 'TV Shows',\n    thriller: 'Thrillers'\n  };\n\n  this.change = function(e) {\n    riot.route('top/' + e.target.value);\n  }.bind(this)\n\n});\n\n  \n\n\n\n/** WEBPACK FOOTER **\n ** ./tags/header/category.tag\n **/","var riot = require(\"riot\");\n\nriot.tag2('header', '<div class=\"container\"> <h1 class=\"title\">Netflix <span>TOP</span></h1> <category category=\"{opts.category}\"></category> </div>', '', '', function(opts) {\n});\n\n\n/** WEBPACK FOOTER **\n ** ./tags/header/header.tag\n **/","var riot = require(\"riot\");\n\nriot.tag2('item', '<img onclick=\"{open}\" data-src=\"{SERVICE_URL + \\'/cover/\\' + data.id}\" src=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\" crossorigin=\"anonymous\"> <div class=\"description\"> <h3>{data.title}</h3> <p>{data.description}</p> <a href=\"{data.link}\" target=\"blank\">{data.link}</a> </div>', '', 'class=\"{opened: opened}\"', function(opts) {\n\n  const isServer = !!(typeof window === 'undefined');\n\n  this.data = opts.data;\n  this.opened = false;\n\n  open = function(e) {\n    e.stopImmediatePropagation()\n    this.parent.open(this);\n  }\n\n  this.lazyload = () => {\n    var rect = this.root.getBoundingClientRect();\n\n    const inView = rect.top >= 0 && rect.left >= 0 &&\n        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) + 300 &&\n        rect.right <= (window.innerWidth || document.documentElement.clientWidth);\n\n    if (inView) {\n      this.img.setAttribute('src', this.img.getAttribute('data-src'));\n      window.removeEventListener('scroll', this.lazyload);\n      window.removeEventListener('resize', this.lazyload);\n    }\n  };\n\n  this.on('mount', function() {\n    if (isServer) return;\n\n    this.img = this.root.querySelector('img');\n    document.addEventListener('scroll', this.lazyload);\n    document.addEventListener('resize', this.lazyload);\n    setTimeout(() => this.lazyload());\n  })\n\n  this.on('unmount', function() {\n    if (isServer) return;\n    window.removeEventListener('scroll', this.lazyload);\n    window.removeEventListener('resize', this.lazyload);\n  })\n\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./tags/item.tag\n **/","'use strict';\n\nconst redux = require('redux');\nconst INITIAL_STATE = (typeof STORE != 'undefined') ? STORE : {\n  title: '',\n  category: '',\n  rendered: false,\n  items: {\n    isFetching: false,\n    hasError: false,\n    data: []\n  }\n};\n\nconst actions = {\n  'UPDATE_TITLE': (state, action) => {\n    return Object.assign({}, state, {title: action.data});\n  },\n  'SERVER_RENDERED': (state, action) => {\n    return Object.assign({}, state, {rendered: true});\n  },\n  'UPDATE_CATEGORY': (state, action) => {\n    return Object.assign({}, state, {category: action.data});\n  },\n  'FETCH_INIT': (state, action) => {\n    return Object.assign({}, state, {\n      items: {\n        isFetching: true,\n        hasError: false\n      }\n    });\n  },\n  'FETCH_SUCCESS': (state, action) => {\n    return Object.assign({}, state, {\n      title: action.data.title,\n      items: {\n        isFetching: false,\n        hasError: false,\n        data: action.data.items\n      }\n    });\n  },\n  'FETCH_ERROR': (state, action) => {\n    return Object.assign({}, state, {\n      items: {\n        isFetching: false,\n        hasError: true,\n        data: action.data\n      }\n    });\n  }\n};\n\nconst reducer = (state, action) => {\n  const update = actions[action.type] && actions[action.type](state, action) || null;\n  return update || state || INITIAL_STATE;\n};\n\nmodule.exports = redux.createStore(reducer);\n\n\n/** WEBPACK FOOTER **\n ** ../store/index.js\n **/","module.exports = Canvas;\n\nfunction Canvas(img){\n  if(!(this instanceof Canvas)){\n    return new Canvas();\n  }\n\n  this.canvas  = document.createElement('canvas');\n  this.context = this.canvas.getContext('2d');\n\n  document.body.appendChild(this.canvas);\n\n  this.width  = this.canvas.width  = img.width;\n  this.height = this.canvas.height = img.height;\n  this.context.drawImage(img, 0, 0, this.width, this.height);\n}\n\nCanvas.prototype.getSize = function(){\n  return this.width * this.height;\n}\n\nCanvas.prototype.getData = function(){\n  return this.context.getImageData(0, 0, this.width, this.height);\n}\n\nCanvas.prototype.delete = function(){\n  this.canvas.parentNode.removeChild(this.canvas);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/colorchart/lib/canvas.js\n ** module id = 12\n ** module chunks = 0\n **/","var quantize = require('quantize');\nvar Canvas = require('./canvas');\n\nmodule.exports = Colormap;\n\nfunction Colormap(){\n  if(!(this instanceof Colormap)){\n    return new Colormap();\n  }\n}\n\nColormap.prototype.get = function(img, count, quality){\n  var mapQuality = quality || 10;\n  var colorCount = count;\n\n  if(!count || count == '1'){\n    colorCount = 5;\n  }\n\n  var canvas = new Canvas(img);\n  var canvasData = canvas.getData();\n  var pixels = canvasData.data;\n  var size = canvas.getSize();\n\n  // canvas RGB values in an array format suitable for quantize function\n  var rgbArray = [];\n\n  for (var i = 0, offset, r, g, b, a; i < size; i = i + mapQuality) {\n    offset = i * 4;\n    r = pixels[offset + 0];\n    g = pixels[offset + 1];\n    b = pixels[offset + 2];\n    a = pixels[offset + 3];\n\n    // if a pixel is mostly opaque and not white\n    if (a >= 125) {\n      if (!(r > 250 && g > 250 && b > 250)) {\n        rgbArray.push([r, g, b]);\n      }\n    }\n  }\n\n  var result = quantize(rgbArray, colorCount);\n  canvas.delete();\n\n  return result.palette().slice(0, count);\n}\n\nColormap.prototype.getDominant = function(img){\n  return this.get(img, 1)[0];\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/colorchart/lib/index.js\n ** module id = 13\n ** module chunks = 0\n **/","/*\n * quantize.js Copyright 2008 Nick Rabinowitz\n * Ported to node.js by Olivier Lesnicki\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n\n// fill out a couple protovis dependencies\n/*\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\nif (!pv) {\n    var pv = {\n        map: function(array, f) {\n            var o = {};\n            return f ? array.map(function(d, i) {\n                o.index = i;\n                return f.call(o, d);\n            }) : array.slice();\n        },\n        naturalOrder: function(a, b) {\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        },\n        sum: function(array, f) {\n            var o = {};\n            return array.reduce(f ? function(p, d, i) {\n                o.index = i;\n                return p + f.call(o, d);\n            } : function(p, d) {\n                return p + d;\n            }, 0);\n        },\n        max: function(array, f) {\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\n        }\n    }\n}\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n * \n * @author Nick Rabinowitz\n * @example\n \n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n \nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) { \n    return cmap.map(p); \n});\n \n */\nvar MMCQ = (function() {\n    // private constants\n    var sigbits = 5,\n        rshift = 8 - sigbits,\n        maxIterations = 1000,\n        fractByPopulations = 0.75;\n\n    // get reduced-space color index for a pixel\n\n    function getColorIndex(r, g, b) {\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\n    }\n\n    // Simple priority queue\n\n    function PQueue(comparator) {\n        var contents = [],\n            sorted = false;\n\n        function sort() {\n            contents.sort(comparator);\n            sorted = true;\n        }\n\n        return {\n            push: function(o) {\n                contents.push(o);\n                sorted = false;\n            },\n            peek: function(index) {\n                if (!sorted) sort();\n                if (index === undefined) index = contents.length - 1;\n                return contents[index];\n            },\n            pop: function() {\n                if (!sorted) sort();\n                return contents.pop();\n            },\n            size: function() {\n                return contents.length;\n            },\n            map: function(f) {\n                return contents.map(f);\n            },\n            debug: function() {\n                if (!sorted) sort();\n                return contents;\n            }\n        };\n    }\n\n    // 3d color space box\n\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n        var vbox = this;\n        vbox.r1 = r1;\n        vbox.r2 = r2;\n        vbox.g1 = g1;\n        vbox.g2 = g2;\n        vbox.b1 = b1;\n        vbox.b2 = b2;\n        vbox.histo = histo;\n    }\n    VBox.prototype = {\n        volume: function(force) {\n            var vbox = this;\n            if (!vbox._volume || force) {\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n            }\n            return vbox._volume;\n        },\n        count: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._count_set || force) {\n                var npix = 0,\n                    i, j, k, index;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            index = getColorIndex(i, j, k);\n                            npix += (histo[index] || 0);\n                        }\n                    }\n                }\n                vbox._count = npix;\n                vbox._count_set = true;\n            }\n            return vbox._count;\n        },\n        copy: function() {\n            var vbox = this;\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n        },\n        avg: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._avg || force) {\n                var ntot = 0,\n                    mult = 1 << (8 - sigbits),\n                    rsum = 0,\n                    gsum = 0,\n                    bsum = 0,\n                    hval,\n                    i, j, k, histoindex;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            histoindex = getColorIndex(i, j, k);\n                            hval = histo[histoindex] || 0;\n                            ntot += hval;\n                            rsum += (hval * (i + 0.5) * mult);\n                            gsum += (hval * (j + 0.5) * mult);\n                            bsum += (hval * (k + 0.5) * mult);\n                        }\n                    }\n                }\n                if (ntot) {\n                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\n                } else {\n                    //console.log('empty box');\n                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n                }\n            }\n            return vbox._avg;\n        },\n        contains: function(pixel) {\n            var vbox = this,\n                rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n                gval >= vbox.g1 && gval <= vbox.g2 &&\n                bval >= vbox.b1 && bval <= vbox.b2);\n        }\n    };\n\n    // Color map\n\n    function CMap() {\n        this.vboxes = new PQueue(function(a, b) {\n            return pv.naturalOrder(\n                a.vbox.count() * a.vbox.volume(),\n                b.vbox.count() * b.vbox.volume()\n            )\n        });;\n    }\n    CMap.prototype = {\n        push: function(vbox) {\n            this.vboxes.push({\n                vbox: vbox,\n                color: vbox.avg()\n            });\n        },\n        palette: function() {\n            return this.vboxes.map(function(vb) {\n                return vb.color\n            });\n        },\n        size: function() {\n            return this.vboxes.size();\n        },\n        map: function(color) {\n            var vboxes = this.vboxes;\n            for (var i = 0; i < vboxes.size(); i++) {\n                if (vboxes.peek(i).vbox.contains(color)) {\n                    return vboxes.peek(i).color;\n                }\n            }\n            return this.nearest(color);\n        },\n        nearest: function(color) {\n            var vboxes = this.vboxes,\n                d1, d2, pColor;\n            for (var i = 0; i < vboxes.size(); i++) {\n                d2 = Math.sqrt(\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n                );\n                if (d2 < d1 || d1 === undefined) {\n                    d1 = d2;\n                    pColor = vboxes.peek(i).color;\n                }\n            }\n            return pColor;\n        },\n        forcebw: function() {\n            // XXX: won't  work yet\n            var vboxes = this.vboxes;\n            vboxes.sort(function(a, b) {\n                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\n            });\n\n            // force darkest color to black if everything < 5\n            var lowest = vboxes[0].color;\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n                vboxes[0].color = [0, 0, 0];\n\n            // force lightest color to white if everything > 251\n            var idx = vboxes.length - 1,\n                highest = vboxes[idx].color;\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n                vboxes[idx].color = [255, 255, 255];\n        }\n    };\n\n    // histo (1-d array, giving the number of pixels in\n    // each quantized region of color space), or null on error\n\n    function getHisto(pixels) {\n        var histosize = 1 << (3 * sigbits),\n            histo = new Array(histosize),\n            index, rval, gval, bval;\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            index = getColorIndex(rval, gval, bval);\n            histo[index] = (histo[index] || 0) + 1;\n        });\n        return histo;\n    }\n\n    function vboxFromPixels(pixels, histo) {\n        var rmin = 1000000,\n            rmax = 0,\n            gmin = 1000000,\n            gmax = 0,\n            bmin = 1000000,\n            bmax = 0,\n            rval, gval, bval;\n        // find min/max\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            if (rval < rmin) rmin = rval;\n            else if (rval > rmax) rmax = rval;\n            if (gval < gmin) gmin = gval;\n            else if (gval > gmax) gmax = gval;\n            if (bval < bmin) bmin = bval;\n            else if (bval > bmax) bmax = bval;\n        });\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n    }\n\n    function medianCutApply(histo, vbox) {\n        if (!vbox.count()) return;\n\n        var rw = vbox.r2 - vbox.r1 + 1,\n            gw = vbox.g2 - vbox.g1 + 1,\n            bw = vbox.b2 - vbox.b1 + 1,\n            maxw = pv.max([rw, gw, bw]);\n        // only one pixel, no split\n        if (vbox.count() == 1) {\n            return [vbox.copy()]\n        }\n        /* Find the partial sum arrays along the selected axis. */\n        var total = 0,\n            partialsum = [],\n            lookaheadsum = [],\n            i, j, k, sum, index;\n        if (maxw == rw) {\n            for (i = vbox.r1; i <= vbox.r2; i++) {\n                sum = 0;\n                for (j = vbox.g1; j <= vbox.g2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(i, j, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else if (maxw == gw) {\n            for (i = vbox.g1; i <= vbox.g2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(j, i, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else { /* maxw == bw */\n            for (i = vbox.b1; i <= vbox.b2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\n                        index = getColorIndex(j, k, i);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        partialsum.forEach(function(d, i) {\n            lookaheadsum[i] = total - d\n        });\n\n        function doCut(color) {\n            var dim1 = color + '1',\n                dim2 = color + '2',\n                left, right, vbox1, vbox2, d2, count2 = 0;\n            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n                if (partialsum[i] > total / 2) {\n                    vbox1 = vbox.copy();\n                    vbox2 = vbox.copy();\n                    left = i - vbox[dim1];\n                    right = vbox[dim2] - i;\n                    if (left <= right)\n                        d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\n                    else d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\n                    // avoid 0-count boxes\n                    while (!partialsum[d2]) d2++;\n                    count2 = lookaheadsum[d2];\n                    while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\n                    // set dimensions\n                    vbox1[dim2] = d2;\n                    vbox2[dim1] = vbox1[dim2] + 1;\n                    // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n                    return [vbox1, vbox2];\n                }\n            }\n\n        }\n        // determine the cut planes\n        return maxw == rw ? doCut('r') :\n            maxw == gw ? doCut('g') :\n            doCut('b');\n    }\n\n    function quantize(pixels, maxcolors) {\n        // short-circuit\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n            // console.log('wrong number of maxcolors');\n            return false;\n        }\n\n        // XXX: check color content and convert to grayscale if insufficient\n\n        var histo = getHisto(pixels),\n            histosize = 1 << (3 * sigbits);\n\n        // check that we aren't below maxcolors already\n        var nColors = 0;\n        histo.forEach(function() {\n            nColors++\n        });\n        if (nColors <= maxcolors) {\n            // XXX: generate the new colors from the histo and return\n        }\n\n        // get the beginning vbox from the colors\n        var vbox = vboxFromPixels(pixels, histo),\n            pq = new PQueue(function(a, b) {\n                return pv.naturalOrder(a.count(), b.count())\n            });\n        pq.push(vbox);\n\n        // inner function to do the iteration\n\n        function iter(lh, target) {\n            var ncolors = 1,\n                niters = 0,\n                vbox;\n            while (niters < maxIterations) {\n                vbox = lh.pop();\n                if (!vbox.count()) { /* just put it back */\n                    lh.push(vbox);\n                    niters++;\n                    continue;\n                }\n                // do the cut\n                var vboxes = medianCutApply(histo, vbox),\n                    vbox1 = vboxes[0],\n                    vbox2 = vboxes[1];\n\n                if (!vbox1) {\n                    // console.log(\"vbox1 not defined; shouldn't happen!\");\n                    return;\n                }\n                lh.push(vbox1);\n                if (vbox2) { /* vbox2 can be null */\n                    lh.push(vbox2);\n                    ncolors++;\n                }\n                if (ncolors >= target) return;\n                if (niters++ > maxIterations) {\n                    // console.log(\"infinite loop; perhaps too few pixels!\");\n                    return;\n                }\n            }\n        }\n\n        // first set of colors, sorted by population\n        iter(pq, fractByPopulations * maxcolors);\n        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n\n        // Re-sort by the product of pixel occupancy times the size in color space.\n        var pq2 = new PQueue(function(a, b) {\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\n        });\n        while (pq.size()) {\n            pq2.push(pq.pop());\n        }\n\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        iter(pq2, maxcolors - pq2.size());\n\n        // calculate the actual colors\n        var cmap = new CMap();\n        while (pq2.size()) {\n            cmap.push(pq2.pop());\n        }\n\n        return cmap;\n    }\n\n    return {\n        quantize: quantize\n    }\n})();\n\nmodule.exports = MMCQ.quantize\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/colorchart/~/quantize/quantize.js\n ** module id = 14\n ** module chunks = 0\n **/","// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\nrequire('whatwg-fetch');\nmodule.exports = self.fetch.bind(self);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/isomorphic-fetch/fetch-npm-browserify.js\n ** module id = 17\n ** module chunks = 0\n **/","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/isomorphic-fetch/~/whatwg-fetch/fetch.js\n ** module id = 18\n ** module chunks = 0\n **/","/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetPrototype = Object.getPrototypeOf;\n\n/**\n * Gets the `[[Prototype]]` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {null|Object} Returns the `[[Prototype]]`.\n */\nfunction getPrototype(value) {\n  return nativeGetPrototype(Object(value));\n}\n\nmodule.exports = getPrototype;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/lodash/_getPrototype.js\n ** module id = 19\n ** module chunks = 0\n **/","/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\nmodule.exports = isHostObject;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/lodash/_isHostObject.js\n ** module id = 20\n ** module chunks = 0\n **/","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/lodash/isObjectLike.js\n ** module id = 21\n ** module chunks = 0\n **/","var appCacheIframe;\n\nfunction hasSW() {\n  return 'serviceWorker' in navigator &&\n    // This is how I block Chrome 40 and detect Chrome 41, because first has\n    // bugs with history.pustState and/or hashchange\n    (window.fetch || 'imageRendering' in document.documentElement.style) &&\n    (window.location.protocol === 'https:' || window.location.hostname === 'localhost')\n}\n\nfunction install(options) {\n  options || (options = {});\n\n  \n    if (hasSW()) {\n      var registration = navigator.serviceWorker\n        .register(\"/sw.js\");\n\n      \n\n      return;\n    }\n  \n\n  \n    if (window.applicationCache) {\n      var directory = \"/appcache/\";\n      var name = \"manifest\";\n\n      var doLoad = function() {\n        var page = directory + name + '.html';\n        var iframe = document.createElement('iframe');\n\n        \n\n        iframe.src = page;\n        iframe.style.display = 'none';\n\n        appCacheIframe = iframe;\n        document.body.appendChild(iframe);\n      };\n\n      if (document.readyState === 'complete') {\n        setTimeout(doLoad);\n      } else {\n        window.addEventListener('load', doLoad);\n      }\n\n      return;\n    }\n  \n}\n\nfunction applyUpdate(callback, errback) {\n  \n\n  \n}\n\nexports.install = install;\nexports.applyUpdate = applyUpdate;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/offline-plugin/runtime.js\n ** module id = 22\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports[\"default\"] = applyMiddleware;\n\nvar _compose = require('./compose');\n\nvar _compose2 = _interopRequireDefault(_compose);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function (reducer, initialState, enhancer) {\n      var store = createStore(reducer, initialState, enhancer);\n      var _dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch(action) {\n          return _dispatch(action);\n        }\n      };\n      chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = _compose2[\"default\"].apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/redux/lib/applyMiddleware.js\n ** module id = 23\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = bindActionCreators;\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(undefined, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/redux/lib/bindActionCreators.js\n ** module id = 24\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = combineReducers;\n\nvar _createStore = require('./createStore');\n\nvar _isPlainObject = require('lodash/isPlainObject');\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _warning = require('./utils/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionName = actionType && '\"' + actionType.toString() + '\"' || 'an action';\n\n  return 'Given action ' + actionName + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!(0, _isPlainObject2[\"default\"])(inputState)) {\n    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key);\n  });\n\n  if (unexpectedKeys.length > 0) {\n    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n  }\n}\n\nfunction assertReducerSanity(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');\n    }\n\n    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n    if (typeof reducer(undefined, { type: type }) === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers);\n\n  var sanityError;\n  try {\n    assertReducerSanity(finalReducers);\n  } catch (e) {\n    sanityError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n    var action = arguments[1];\n\n    if (sanityError) {\n      throw sanityError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);\n      if (warningMessage) {\n        (0, _warning2[\"default\"])(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n    for (var i = 0; i < finalReducerKeys.length; i++) {\n      var key = finalReducerKeys[i];\n      var reducer = finalReducers[key];\n      var previousStateForKey = state[key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/redux/lib/combineReducers.js\n ** module id = 25\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;\n\nvar _createStore = require('./createStore');\n\nvar _createStore2 = _interopRequireDefault(_createStore);\n\nvar _combineReducers = require('./combineReducers');\n\nvar _combineReducers2 = _interopRequireDefault(_combineReducers);\n\nvar _bindActionCreators = require('./bindActionCreators');\n\nvar _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);\n\nvar _applyMiddleware = require('./applyMiddleware');\n\nvar _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);\n\nvar _compose = require('./compose');\n\nvar _compose2 = _interopRequireDefault(_compose);\n\nvar _warning = require('./utils/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*\n* This is a dummy function to check if the function name has been altered by minification.\n* If the function has been minified and NODE_ENV !== 'production', warn the user.\n*/\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  (0, _warning2[\"default\"])('You are currently using minified code outside of NODE_ENV === \\'production\\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');\n}\n\nexports.createStore = _createStore2[\"default\"];\nexports.combineReducers = _combineReducers2[\"default\"];\nexports.bindActionCreators = _bindActionCreators2[\"default\"];\nexports.applyMiddleware = _applyMiddleware2[\"default\"];\nexports.compose = _compose2[\"default\"];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/redux/lib/index.js\n ** module id = 26\n ** module chunks = 0\n **/","/* global window */\n'use strict';\n\nmodule.exports = require('./ponyfill')(global || window || this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/redux/~/symbol-observable/index.js\n ** module id = 27\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/jtroendle/Documents/netflix-top/~/redux/~/symbol-observable/ponyfill.js\n ** module id = 28\n ** module chunks = 0\n **/","module.exports = __webpack_amd_options__;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-options.js\n ** module id = 29\n ** module chunks = 0\n **/","var map = {\n\t\"./app.tag\": 6,\n\t\"./footer.tag\": 7,\n\t\"./header/category.tag\": 8,\n\t\"./header/header.tag\": 9,\n\t\"./item.tag\": 10\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 30;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./tags \\.tag$\n ** module id = 30\n ** module chunks = 0\n **/"],"sourceRoot":""}